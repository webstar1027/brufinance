{"version":3,"mappings":"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ACA,WACA,mBACA,UACA,qBACA,SACA,gBACA,qBACA,wBACA,0BAOEC,EAAyB,CAAC,YAAa,gBAAiB,YAAa,oBAAqB,mBA6D1FC,EAAkB,CAAC,QACnBC,GAAqB,CAAC,OAAQ,QAAS,QAAS,OAAQ,SAAU,SAAU,gBAC5EC,GAAoB,CAAC,SAAU,SAAU,SACzCC,GAA2B,CAC7B,YAAa,WAAY,QAAS,QAAS,OAAQ,WAAY,UAAW,UAC1E,oBAEEC,GAAqB,CAAC,gBAAiB,WAAY,QAAS,UAAW,QAAS,UAAW,gBAAiB,SAC5GC,GAAsB,CAAC,QAAS,QAAS,OAAQ,WACjDC,GAAmB,CAAC,QAAS,WAC7BC,GApNgC,CAClC,QACA,kBACA,eACA,qBACA,WACA,cACA,OACA,SACA,UACA,iBACA,SACA,mBACA,oBACA,iBACA,YACA,QACA,QACA,cACA,aACA,WACA,OACA,UACA,YACA,WACA,YACA,WACA,OACA,iBACA,UACA,QACA,QACA,QACA,UACA,WACA,oBACA,QACA,UACA,UACA,WACA,QACA,OACA,YACA,aACA,iBACA,qBACA,YACA,aACA,aACA,YACA,WACA,YACA,UACA,aACA,oBACA,QACA,OACA,UACA,gBACA,cACA,eACA,eACA,oBACA,uBACA,4BACA,mBACA,sBACA,yBACA,cACA,WACA,cACA,YACA,WACA,aACA,QACA,SACA,SACA,SACA,UACA,SACA,kBACA,cACA,OACA,OACA,UACA,SACA,UACA,aACA,eACA,cACA,YACA,aACA,WACA,mBACA,gBACA,UACA,SAoH6CplB,OAbzB,CAAC,uBAAwB,mBAAoB,6BAC9C,CAAC,eAAgB,qBACf,CAAC,UAvGC,CACvB,qBAAsB,sBAAuB,mBAAoB,SAAU,mBAC3E,sBAAuB,yBAA0B,qBAAsB,kBACvE,qBAAsB,wBAAyB,oBAAqB,mBACpE,mBAAoB,UA8GuG2kB,EA5EjG,CAC1B,aAAc,YAAa,cAAe,OAAQ,MAAO,QAAS,YAAa,UAC/E,iBAAkB,SAAU,gBAAiB,kBAAmB,qBAChE,2BAA4B,uBAAwB,uBAG5B,CACxB,WACA,cACA,cACA,iBACA,mBACA,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","names":["exports","b64","lens","getLens","placeHoldersLen","tmp","i","validLen","arr","Arr","_byteLength","curByte","len","revLookup","charCodeAt","uint8","length","extraBytes","parts","len2","push","encodeChunk","lookup","join","Uint8Array","Array","code","Error","indexOf","num","start","end","output","tripletToBase64","base64","require","ieee754","customInspectSymbol","Symbol","for","Buffer","alloc","K_MAX_LENGTH","RangeError","buf","Object","setPrototypeOf","prototype","arg","encodingOrOffset","TypeError","allocUnsafe","from","value","string","encoding","isEncoding","byteLength","createBuffer","actual","write","slice","fromString","ArrayBuffer","isView","arrayView","isInstance","copy","fromArrayBuffer","buffer","byteOffset","fromArrayLike","fromArrayView","SharedArrayBuffer","valueOf","b","obj","isBuffer","checked","undefined","numberIsNaN","type","isArray","data","fromObject","toPrimitive","size","assertSize","array","toString","mustMatch","arguments","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","this","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","n","m","val","dir","t","arrayIndexOf","call","lastIndexOf","indexSize","arrLength","valLength","String","readUInt16BE","foundIndex","read","found","j","offset","Number","remaining","strLen","parsed","parseInt","substr","blitBuffer","str","byteArray","asciiToBytes","units","c","hi","utf16leToBytes","fromByteArray","Math","min","res","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","codePoints","fromCharCode","apply","decodeCodePointsArray","ret","out","hexSliceLookupTable","bytes","ext","max","littleEndian","noAssert","checkIEEE754","TYPED_ARRAY_SUPPORT","proto","foo","e","typedArraySupport","console","error","defineProperty","enumerable","get","poolSize","fill","allocUnsafeSlow","_isBuffer","compare","a","x","y","concat","list","pos","set","swap16","swap","swap32","swap64","toLocaleString","slowToString","equals","inspect","INSPECT_MAX_BYTES","replace","trim","target","thisStart","thisEnd","thisCopy","targetCopy","includes","bidirectionalIndexOf","isFinite","hexWrite","utf8Write","asciiWrite","base64Write","ucs2Write","toJSON","_arr","newBuf","subarray","readUintLE","readUIntLE","checkOffset","mul","readUintBE","readUIntBE","readUint8","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUintLE","writeUIntLE","checkInt","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloat","writeFloatBE","writeDoubleLE","writeDouble","writeDoubleBE","targetStart","copyWithin","INVALID_BASE64_RE","Infinity","leadSurrogate","toByteArray","split","base64clean","src","dst","constructor","name","alphabet","table","i16","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","d","s","NaN","rt","abs","isNaN","floor","log","LN2","R","cachedSetTimeout","cachedClearTimeout","process","module","fun","setTimeout","defaultSetTimout","clearTimeout","defaultClearTimeout","currentQueue","queue","draining","queueIndex","drainQueue","timeout","runTimeout","cleanUpNextTick","run","marker","runClearTimeout","nextTick","args","Item","title","browser","env","argv","version","versions","on","noop","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","umask","global","performance","mark","label","measure","symbolPrefix","__Zone_symbol_prefix","checkDuplicate","__symbol__","Zone","parent","zoneSpec","_parent","_name","_properties","properties","_zoneDelegate","ZoneDelegate","Promise","patches","ZoneAwarePromise","zone","current","_currentZoneFrame","_currentTask","fn","ignoreDuplicate","hasOwnProperty","perfName","_api","performanceMeasure","key","getZoneWith","fork","wrap","callback","source","_callback","intercept","runGuarded","applyThis","applyArgs","invoke","handleError","runTask","task","NO_ZONE","state","notScheduled","eventTask","macroTask","reEntryGuard","running","_transitionTo","scheduled","runCount","previousTask","isPeriodic","cancelFn","invokeTask","unknown","_updateTaskCount","scheduleTask","newZone","scheduling","zoneDelegates","_zoneDelegates","_zone","err","scheduleMicroTask","customSchedule","ZoneTask","microTask","scheduleMacroTask","customCancel","scheduleEventTask","cancelTask","canceling","count","DELEGATE_ZS","onHasTask","delegate","_","hasTaskState","hasTask","onScheduleTask","onInvokeTask","onCancelTask","parentDelegate","_taskCounts","_parentDelegate","_forkZS","onFork","_forkDlgt","_forkCurrZone","_interceptZS","onIntercept","_interceptDlgt","_interceptCurrZone","_invokeZS","onInvoke","_invokeDlgt","_invokeCurrZone","_handleErrorZS","onHandleError","_handleErrorDlgt","_handleErrorCurrZone","_scheduleTaskZS","_scheduleTaskDlgt","_scheduleTaskCurrZone","_invokeTaskZS","_invokeTaskDlgt","_invokeTaskCurrZone","_cancelTaskZS","_cancelTaskDlgt","_cancelTaskCurrZone","_hasTaskZS","_hasTaskDlgt","_hasTaskDlgtOwner","_hasTaskCurrZone","zoneSpecHasTask","targetZone","returnTask","scheduleFn","isEmpty","counts","prev","next","change","options","_state","self","useG","_numberOfNestedTaskFrames","drainMicroTaskQueue","cancelScheduleRequest","toState","fromState1","fromState2","handleId","symbolSetTimeout","symbolPromise","symbolThen","nativeMicroTaskQueuePromise","_microTaskQueue","_isDrainingMicrotaskQueue","resolve","nativeThen","then","onUnhandledError","microtaskDrainDone","symbol","currentZoneFrame","showUncaughtError","patchEventTarget","patchOnProperties","patchMethod","bindArguments","patchThen","patchMacroTask","patchEventPrototype","isIEOrEdge","getGlobalObjects","ObjectDefineProperty","ObjectGetOwnPropertyDescriptor","ObjectCreate","ArraySlice","patchClass","wrapWithCurrentZone","filterProperties","attachOriginToPatched","_redefineProperty","patchCallbacks","window","getOwnPropertyDescriptor","ObjectGetPrototypeOf","getPrototypeOf","create","ADD_EVENT_LISTENER_STR","REMOVE_EVENT_LISTENER_STR","ZONE_SYMBOL_ADD_EVENT_LISTENER","ZONE_SYMBOL_REMOVE_EVENT_LISTENER","TRUE_STR","FALSE_STR","ZONE_SYMBOL_PREFIX","zoneSymbol","isWindowExists","internalWindow","_global","NULL_ON_PROP_VALUE","propertyDesc","writable","isWebWorker","WorkerGlobalScope","isNode","isBrowser","HTMLElement","isMix","zoneSymbolEventNames","wrapFn","event","eventNameSymbol","listener","result","errorEvent","message","filename","lineno","colno","preventDefault","prop","desc","configurable","onPropPatchedSymbol","originalDescGet","originalDescSet","eventName","newValue","removeEventListener","addEventListener","REMOVE_ATTRIBUTE","removeAttribute","patchProperty","onProperties","originalInstanceKey","className","OriginalClass","instance","patchFn","delegateName","isPropertyWritable","patchDelegate","funcName","metaCreator","setNative","cbIdx","meta","scheduleMacroTaskWithCurrentZone","patched","original","isDetectedIEOrEdge","ieOrEdge","ua","navigator","userAgent","__load_patch","api","_uncaughtPromiseErrors","isDisableWrappingUncaughtPromiseRejection","rejection","stack","uncaughtPromiseError","shift","throwOriginal","handleUnhandledRejection","UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL","handler","reject","symbolState","symbolValue","symbolFinally","symbolParentPromiseValue","symbolParentPromiseState","UNRESOLVED","REJECTED","promise","v","resolvePromise","CURRENT_TASK_TRACE_SYMBOL","onceWrapper","wasCalled","wrappedFunction","clearRejectedNoCatch","makeResolver","trace","currentTask","creationTrace","scheduleResolveOrReject","JSON","stringify","readableObjectToString","REJECTION_HANDLED_HANDLER","splice","chainPromise","onFulfilled","onRejected","promiseState","forwardResolution","forwardRejection","parentPromiseValue","isFinallyPromise","ZONE_AWARE_PROMISE_TO_STRING","values","rej","isThenable","onResolve","onReject","allWithCallback","thenCallback","status","errorCallback","reason","unresolvedCount","valueIndex","resolvedValues","curValueIndex","thenErr","executor","toStringTag","species","C","catch","finally","onFinally","race","all","NativePromise","symbolThenPatched","Ctor","originalThen","wrapped","resultPromise","ctor","zoneify","originalFunctionToString","Function","ORIGINAL_DELEGATE_SYMBOL","PROMISE_SYMBOL","ERROR_SYMBOL","newFunctionToString","originalDelegate","nativePromise","nativeError","originalObjectToString","passiveSupported","OPTIMIZED_ZONE_EVENT_TASK_DATA","zoneSymbolEventNames$1","globalSources","EVENT_NAME_SYMBOL_REGX","RegExp","IMMEDIATE_PROPAGATION_SYMBOL","eventNameToString","falseEventName","trueEventName","symbolCapture","apis","patchOptions","ADD_EVENT_LISTENER","add","REMOVE_EVENT_LISTENER","rm","LISTENERS_EVENT_LISTENER","REMOVE_ALL_LISTENERS_EVENT_LISTENER","rmAll","zoneSymbolAddEventListener","ADD_EVENT_LISTENER_SOURCE","isRemoved","handleEvent","globalZoneAwareCallback","tasks","copyTasks","globalZoneAwareCaptureCallback","useGlobalCallback","validateHandler","vh","chkDup","returnTarget","taskData","nativeAddEventListener","nativeRemoveEventListener","nativeListeners","nativeRemoveAllListeners","nativePrependEventListener","passive","capture","assign","prepend","isExisting","symbolEventNames","symbolEventName","existingTasks","allRemoved","diff","typeOfDelegate","unpatchedEvents","passiveEvents","makeAddListener","nativeListener","addSource","customScheduleFn","customCancelFn","transferEventName","isHandleEvent","buildEventListenerOptions","He","prepareEventNames","constructorName","targetSource","L","unshift","PREPEND_EVENT_LISTENER","existingTask","findEventTasks","captureTasks","removeTasks","keys","match","exec","evtName","results","patchEventTargetMethods","foundTasks","captureFalseTasks","captureTrueTasks","Event","targetName","method","callbacks","nativeDelegate","opts","forEach","descriptor","windowEventNames","mediaElementEventNames","frameEventNames","frameSetEventNames","marqueeEventNames","XMLHttpRequestEventNames","IDBIndexEventNames","websocketEventNames","workerEventNames","eventNames","ignoreProperties","tip","filter","ip","targetIgnoreProperties","op","SYMBOL_BLACK_LISTED_EVENTS","SYMBOL_UNPATCHED_EVENTS","taskSymbol","setName","cancelName","nameSuffix","clearNative","tasksByHandleId","delay","clearTask","handle","ref","unref","bind","id","$","legacyPatch","clear","patchTimer","blockingMethods","patchEvent","EVENT_TARGET","EventTarget","eventTargetPatch","XMLHttpRequestEventTarget","supportsWebSocket","WebSocket","__Zone_ignore_on_properties","ignoreErrorProperties","isIE","patchFilteredProperties","Document","SVGElement","Element","HTMLMediaElement","HTMLFrameSetElement","HTMLBodyElement","HTMLFrameElement","HTMLIFrameElement","HTMLMarqueeElement","Worker","XMLHttpRequest","IDBIndex","IDBRequest","IDBOpenDBRequest","IDBDatabase","IDBTransaction","IDBCursor","propertyDescriptorPatch","customElements","patchCustomElements","XMLHttpRequestPrototype","oriAddListener","oriRemoveListener","XMLHttpRequestEventTargetPrototype","READY_STATE_CHANGE","SCHEDULED","XHR_SCHEDULED","XHR_ERROR_BEFORE_SCHEDULED","XHR_LISTENER","newListener","readyState","DONE","aborted","loadTasks","oriInvoke","storedTask","XHR_TASK","sendNative","abortNative","openNative","XHR_SYNC","XHR_URL","fetchTaskAborting","fetchTaskScheduling","url","placeholderCallback","findPendingTask","patchXHR","geolocation","fnNames","patchPrototype","PromiseRejectionEvent","evt","findPromiseRejectionHandler","__globalThis","globalThis","__window","__self","$localize","messageParts","expressions","translate","translation","stripBlock","raw","messagePart","rawMessagePart","charAt","substring","cooked","cookedIndex","rawIndex","findEndOfBlock"],"sources":["./node_modules/base64-js/index.js","./node_modules/buffer/index.js","./node_modules/ieee754/index.js","./node_modules/process/browser.js","./node_modules/zone.js/fesm2015/zone.js","./node_modules/@angular/localize/fesm2015/init.js","./src/polyfills.ts"],"sourcesContent":["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    var copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        Buffer.from(buf).copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (var i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","'use strict';\n/**\n * @license Angular v12.0.0-next.0\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst Zone$1 = (function (global) {\n    const performance = global['performance'];\n    function mark(name) {\n        performance && performance['mark'] && performance['mark'](name);\n    }\n    function performanceMeasure(name, label) {\n        performance && performance['measure'] && performance['measure'](name, label);\n    }\n    mark('Zone');\n    // Initialize before it's accessed below.\n    // __Zone_symbol_prefix global can be used to override the default zone\n    // symbol prefix with a custom one if needed.\n    const symbolPrefix = global['__Zone_symbol_prefix'] || '__zone_symbol__';\n    function __symbol__(name) {\n        return symbolPrefix + name;\n    }\n    const checkDuplicate = global[__symbol__('forceDuplicateZoneCheck')] === true;\n    if (global['Zone']) {\n        // if global['Zone'] already exists (maybe zone.js was already loaded or\n        // some other lib also registered a global object named Zone), we may need\n        // to throw an error, but sometimes user may not want this error.\n        // For example,\n        // we have two web pages, page1 includes zone.js, page2 doesn't.\n        // and the 1st time user load page1 and page2, everything work fine,\n        // but when user load page2 again, error occurs because global['Zone'] already exists.\n        // so we add a flag to let user choose whether to throw this error or not.\n        // By default, if existing Zone is from zone.js, we will not throw the error.\n        if (checkDuplicate || typeof global['Zone'].__symbol__ !== 'function') {\n            throw new Error('Zone already loaded.');\n        }\n        else {\n            return global['Zone'];\n        }\n    }\n    class Zone {\n        constructor(parent, zoneSpec) {\n            this._parent = parent;\n            this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';\n            this._properties = zoneSpec && zoneSpec.properties || {};\n            this._zoneDelegate =\n                new ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);\n        }\n        static assertZonePatched() {\n            if (global['Promise'] !== patches['ZoneAwarePromise']) {\n                throw new Error('Zone.js has detected that ZoneAwarePromise `(window|global).Promise` ' +\n                    'has been overwritten.\\n' +\n                    'Most likely cause is that a Promise polyfill has been loaded ' +\n                    'after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. ' +\n                    'If you must load one, do so before loading zone.js.)');\n            }\n        }\n        static get root() {\n            let zone = Zone.current;\n            while (zone.parent) {\n                zone = zone.parent;\n            }\n            return zone;\n        }\n        static get current() {\n            return _currentZoneFrame.zone;\n        }\n        static get currentTask() {\n            return _currentTask;\n        }\n        // tslint:disable-next-line:require-internal-with-underscore\n        static __load_patch(name, fn, ignoreDuplicate = false) {\n            if (patches.hasOwnProperty(name)) {\n                // `checkDuplicate` option is defined from global variable\n                // so it works for all modules.\n                // `ignoreDuplicate` can work for the specified module\n                if (!ignoreDuplicate && checkDuplicate) {\n                    throw Error('Already loaded patch: ' + name);\n                }\n            }\n            else if (!global['__Zone_disable_' + name]) {\n                const perfName = 'Zone:' + name;\n                mark(perfName);\n                patches[name] = fn(global, Zone, _api);\n                performanceMeasure(perfName, perfName);\n            }\n        }\n        get parent() {\n            return this._parent;\n        }\n        get name() {\n            return this._name;\n        }\n        get(key) {\n            const zone = this.getZoneWith(key);\n            if (zone)\n                return zone._properties[key];\n        }\n        getZoneWith(key) {\n            let current = this;\n            while (current) {\n                if (current._properties.hasOwnProperty(key)) {\n                    return current;\n                }\n                current = current._parent;\n            }\n            return null;\n        }\n        fork(zoneSpec) {\n            if (!zoneSpec)\n                throw new Error('ZoneSpec required!');\n            return this._zoneDelegate.fork(this, zoneSpec);\n        }\n        wrap(callback, source) {\n            if (typeof callback !== 'function') {\n                throw new Error('Expecting function got: ' + callback);\n            }\n            const _callback = this._zoneDelegate.intercept(this, callback, source);\n            const zone = this;\n            return function () {\n                return zone.runGuarded(_callback, this, arguments, source);\n            };\n        }\n        run(callback, applyThis, applyArgs, source) {\n            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n            try {\n                return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n            }\n            finally {\n                _currentZoneFrame = _currentZoneFrame.parent;\n            }\n        }\n        runGuarded(callback, applyThis = null, applyArgs, source) {\n            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n            try {\n                try {\n                    return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n                }\n                catch (error) {\n                    if (this._zoneDelegate.handleError(this, error)) {\n                        throw error;\n                    }\n                }\n            }\n            finally {\n                _currentZoneFrame = _currentZoneFrame.parent;\n            }\n        }\n        runTask(task, applyThis, applyArgs) {\n            if (task.zone != this) {\n                throw new Error('A task can only be run in the zone of creation! (Creation: ' +\n                    (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');\n            }\n            // https://github.com/angular/zone.js/issues/778, sometimes eventTask\n            // will run in notScheduled(canceled) state, we should not try to\n            // run such kind of task but just return\n            if (task.state === notScheduled && (task.type === eventTask || task.type === macroTask)) {\n                return;\n            }\n            const reEntryGuard = task.state != running;\n            reEntryGuard && task._transitionTo(running, scheduled);\n            task.runCount++;\n            const previousTask = _currentTask;\n            _currentTask = task;\n            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n            try {\n                if (task.type == macroTask && task.data && !task.data.isPeriodic) {\n                    task.cancelFn = undefined;\n                }\n                try {\n                    return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);\n                }\n                catch (error) {\n                    if (this._zoneDelegate.handleError(this, error)) {\n                        throw error;\n                    }\n                }\n            }\n            finally {\n                // if the task's state is notScheduled or unknown, then it has already been cancelled\n                // we should not reset the state to scheduled\n                if (task.state !== notScheduled && task.state !== unknown) {\n                    if (task.type == eventTask || (task.data && task.data.isPeriodic)) {\n                        reEntryGuard && task._transitionTo(scheduled, running);\n                    }\n                    else {\n                        task.runCount = 0;\n                        this._updateTaskCount(task, -1);\n                        reEntryGuard &&\n                            task._transitionTo(notScheduled, running, notScheduled);\n                    }\n                }\n                _currentZoneFrame = _currentZoneFrame.parent;\n                _currentTask = previousTask;\n            }\n        }\n        scheduleTask(task) {\n            if (task.zone && task.zone !== this) {\n                // check if the task was rescheduled, the newZone\n                // should not be the children of the original zone\n                let newZone = this;\n                while (newZone) {\n                    if (newZone === task.zone) {\n                        throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${task.zone.name}`);\n                    }\n                    newZone = newZone.parent;\n                }\n            }\n            task._transitionTo(scheduling, notScheduled);\n            const zoneDelegates = [];\n            task._zoneDelegates = zoneDelegates;\n            task._zone = this;\n            try {\n                task = this._zoneDelegate.scheduleTask(this, task);\n            }\n            catch (err) {\n                // should set task's state to unknown when scheduleTask throw error\n                // because the err may from reschedule, so the fromState maybe notScheduled\n                task._transitionTo(unknown, scheduling, notScheduled);\n                // TODO: @JiaLiPassion, should we check the result from handleError?\n                this._zoneDelegate.handleError(this, err);\n                throw err;\n            }\n            if (task._zoneDelegates === zoneDelegates) {\n                // we have to check because internally the delegate can reschedule the task.\n                this._updateTaskCount(task, 1);\n            }\n            if (task.state == scheduling) {\n                task._transitionTo(scheduled, scheduling);\n            }\n            return task;\n        }\n        scheduleMicroTask(source, callback, data, customSchedule) {\n            return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, undefined));\n        }\n        scheduleMacroTask(source, callback, data, customSchedule, customCancel) {\n            return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));\n        }\n        scheduleEventTask(source, callback, data, customSchedule, customCancel) {\n            return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));\n        }\n        cancelTask(task) {\n            if (task.zone != this)\n                throw new Error('A task can only be cancelled in the zone of creation! (Creation: ' +\n                    (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');\n            task._transitionTo(canceling, scheduled, running);\n            try {\n                this._zoneDelegate.cancelTask(this, task);\n            }\n            catch (err) {\n                // if error occurs when cancelTask, transit the state to unknown\n                task._transitionTo(unknown, canceling);\n                this._zoneDelegate.handleError(this, err);\n                throw err;\n            }\n            this._updateTaskCount(task, -1);\n            task._transitionTo(notScheduled, canceling);\n            task.runCount = 0;\n            return task;\n        }\n        _updateTaskCount(task, count) {\n            const zoneDelegates = task._zoneDelegates;\n            if (count == -1) {\n                task._zoneDelegates = null;\n            }\n            for (let i = 0; i < zoneDelegates.length; i++) {\n                zoneDelegates[i]._updateTaskCount(task.type, count);\n            }\n        }\n    }\n    // tslint:disable-next-line:require-internal-with-underscore\n    Zone.__symbol__ = __symbol__;\n    const DELEGATE_ZS = {\n        name: '',\n        onHasTask: (delegate, _, target, hasTaskState) => delegate.hasTask(target, hasTaskState),\n        onScheduleTask: (delegate, _, target, task) => delegate.scheduleTask(target, task),\n        onInvokeTask: (delegate, _, target, task, applyThis, applyArgs) => delegate.invokeTask(target, task, applyThis, applyArgs),\n        onCancelTask: (delegate, _, target, task) => delegate.cancelTask(target, task)\n    };\n    class ZoneDelegate {\n        constructor(zone, parentDelegate, zoneSpec) {\n            this._taskCounts = { 'microTask': 0, 'macroTask': 0, 'eventTask': 0 };\n            this.zone = zone;\n            this._parentDelegate = parentDelegate;\n            this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);\n            this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);\n            this._forkCurrZone =\n                zoneSpec && (zoneSpec.onFork ? this.zone : parentDelegate._forkCurrZone);\n            this._interceptZS =\n                zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);\n            this._interceptDlgt =\n                zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);\n            this._interceptCurrZone =\n                zoneSpec && (zoneSpec.onIntercept ? this.zone : parentDelegate._interceptCurrZone);\n            this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);\n            this._invokeDlgt =\n                zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);\n            this._invokeCurrZone =\n                zoneSpec && (zoneSpec.onInvoke ? this.zone : parentDelegate._invokeCurrZone);\n            this._handleErrorZS =\n                zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);\n            this._handleErrorDlgt =\n                zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);\n            this._handleErrorCurrZone =\n                zoneSpec && (zoneSpec.onHandleError ? this.zone : parentDelegate._handleErrorCurrZone);\n            this._scheduleTaskZS =\n                zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);\n            this._scheduleTaskDlgt = zoneSpec &&\n                (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);\n            this._scheduleTaskCurrZone =\n                zoneSpec && (zoneSpec.onScheduleTask ? this.zone : parentDelegate._scheduleTaskCurrZone);\n            this._invokeTaskZS =\n                zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);\n            this._invokeTaskDlgt =\n                zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);\n            this._invokeTaskCurrZone =\n                zoneSpec && (zoneSpec.onInvokeTask ? this.zone : parentDelegate._invokeTaskCurrZone);\n            this._cancelTaskZS =\n                zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);\n            this._cancelTaskDlgt =\n                zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);\n            this._cancelTaskCurrZone =\n                zoneSpec && (zoneSpec.onCancelTask ? this.zone : parentDelegate._cancelTaskCurrZone);\n            this._hasTaskZS = null;\n            this._hasTaskDlgt = null;\n            this._hasTaskDlgtOwner = null;\n            this._hasTaskCurrZone = null;\n            const zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;\n            const parentHasTask = parentDelegate && parentDelegate._hasTaskZS;\n            if (zoneSpecHasTask || parentHasTask) {\n                // If we need to report hasTask, than this ZS needs to do ref counting on tasks. In such\n                // a case all task related interceptors must go through this ZD. We can't short circuit it.\n                this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;\n                this._hasTaskDlgt = parentDelegate;\n                this._hasTaskDlgtOwner = this;\n                this._hasTaskCurrZone = zone;\n                if (!zoneSpec.onScheduleTask) {\n                    this._scheduleTaskZS = DELEGATE_ZS;\n                    this._scheduleTaskDlgt = parentDelegate;\n                    this._scheduleTaskCurrZone = this.zone;\n                }\n                if (!zoneSpec.onInvokeTask) {\n                    this._invokeTaskZS = DELEGATE_ZS;\n                    this._invokeTaskDlgt = parentDelegate;\n                    this._invokeTaskCurrZone = this.zone;\n                }\n                if (!zoneSpec.onCancelTask) {\n                    this._cancelTaskZS = DELEGATE_ZS;\n                    this._cancelTaskDlgt = parentDelegate;\n                    this._cancelTaskCurrZone = this.zone;\n                }\n            }\n        }\n        fork(targetZone, zoneSpec) {\n            return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) :\n                new Zone(targetZone, zoneSpec);\n        }\n        intercept(targetZone, callback, source) {\n            return this._interceptZS ?\n                this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) :\n                callback;\n        }\n        invoke(targetZone, callback, applyThis, applyArgs, source) {\n            return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) :\n                callback.apply(applyThis, applyArgs);\n        }\n        handleError(targetZone, error) {\n            return this._handleErrorZS ?\n                this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) :\n                true;\n        }\n        scheduleTask(targetZone, task) {\n            let returnTask = task;\n            if (this._scheduleTaskZS) {\n                if (this._hasTaskZS) {\n                    returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);\n                }\n                // clang-format off\n                returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);\n                // clang-format on\n                if (!returnTask)\n                    returnTask = task;\n            }\n            else {\n                if (task.scheduleFn) {\n                    task.scheduleFn(task);\n                }\n                else if (task.type == microTask) {\n                    scheduleMicroTask(task);\n                }\n                else {\n                    throw new Error('Task is missing scheduleFn.');\n                }\n            }\n            return returnTask;\n        }\n        invokeTask(targetZone, task, applyThis, applyArgs) {\n            return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) :\n                task.callback.apply(applyThis, applyArgs);\n        }\n        cancelTask(targetZone, task) {\n            let value;\n            if (this._cancelTaskZS) {\n                value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);\n            }\n            else {\n                if (!task.cancelFn) {\n                    throw Error('Task is not cancelable');\n                }\n                value = task.cancelFn(task);\n            }\n            return value;\n        }\n        hasTask(targetZone, isEmpty) {\n            // hasTask should not throw error so other ZoneDelegate\n            // can still trigger hasTask callback\n            try {\n                this._hasTaskZS &&\n                    this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);\n            }\n            catch (err) {\n                this.handleError(targetZone, err);\n            }\n        }\n        // tslint:disable-next-line:require-internal-with-underscore\n        _updateTaskCount(type, count) {\n            const counts = this._taskCounts;\n            const prev = counts[type];\n            const next = counts[type] = prev + count;\n            if (next < 0) {\n                throw new Error('More tasks executed then were scheduled.');\n            }\n            if (prev == 0 || next == 0) {\n                const isEmpty = {\n                    microTask: counts['microTask'] > 0,\n                    macroTask: counts['macroTask'] > 0,\n                    eventTask: counts['eventTask'] > 0,\n                    change: type\n                };\n                this.hasTask(this.zone, isEmpty);\n            }\n        }\n    }\n    class ZoneTask {\n        constructor(type, source, callback, options, scheduleFn, cancelFn) {\n            // tslint:disable-next-line:require-internal-with-underscore\n            this._zone = null;\n            this.runCount = 0;\n            // tslint:disable-next-line:require-internal-with-underscore\n            this._zoneDelegates = null;\n            // tslint:disable-next-line:require-internal-with-underscore\n            this._state = 'notScheduled';\n            this.type = type;\n            this.source = source;\n            this.data = options;\n            this.scheduleFn = scheduleFn;\n            this.cancelFn = cancelFn;\n            if (!callback) {\n                throw new Error('callback is not defined');\n            }\n            this.callback = callback;\n            const self = this;\n            // TODO: @JiaLiPassion options should have interface\n            if (type === eventTask && options && options.useG) {\n                this.invoke = ZoneTask.invokeTask;\n            }\n            else {\n                this.invoke = function () {\n                    return ZoneTask.invokeTask.call(global, self, this, arguments);\n                };\n            }\n        }\n        static invokeTask(task, target, args) {\n            if (!task) {\n                task = this;\n            }\n            _numberOfNestedTaskFrames++;\n            try {\n                task.runCount++;\n                return task.zone.runTask(task, target, args);\n            }\n            finally {\n                if (_numberOfNestedTaskFrames == 1) {\n                    drainMicroTaskQueue();\n                }\n                _numberOfNestedTaskFrames--;\n            }\n        }\n        get zone() {\n            return this._zone;\n        }\n        get state() {\n            return this._state;\n        }\n        cancelScheduleRequest() {\n            this._transitionTo(notScheduled, scheduling);\n        }\n        // tslint:disable-next-line:require-internal-with-underscore\n        _transitionTo(toState, fromState1, fromState2) {\n            if (this._state === fromState1 || this._state === fromState2) {\n                this._state = toState;\n                if (toState == notScheduled) {\n                    this._zoneDelegates = null;\n                }\n            }\n            else {\n                throw new Error(`${this.type} '${this.source}': can not transition to '${toState}', expecting state '${fromState1}'${fromState2 ? ' or \\'' + fromState2 + '\\'' : ''}, was '${this._state}'.`);\n            }\n        }\n        toString() {\n            if (this.data && typeof this.data.handleId !== 'undefined') {\n                return this.data.handleId.toString();\n            }\n            else {\n                return Object.prototype.toString.call(this);\n            }\n        }\n        // add toJSON method to prevent cyclic error when\n        // call JSON.stringify(zoneTask)\n        toJSON() {\n            return {\n                type: this.type,\n                state: this.state,\n                source: this.source,\n                zone: this.zone.name,\n                runCount: this.runCount\n            };\n        }\n    }\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    ///  MICROTASK QUEUE\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    const symbolSetTimeout = __symbol__('setTimeout');\n    const symbolPromise = __symbol__('Promise');\n    const symbolThen = __symbol__('then');\n    let _microTaskQueue = [];\n    let _isDrainingMicrotaskQueue = false;\n    let nativeMicroTaskQueuePromise;\n    function scheduleMicroTask(task) {\n        // if we are not running in any task, and there has not been anything scheduled\n        // we must bootstrap the initial task creation by manually scheduling the drain\n        if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {\n            // We are not running in Task, so we need to kickstart the microtask queue.\n            if (!nativeMicroTaskQueuePromise) {\n                if (global[symbolPromise]) {\n                    nativeMicroTaskQueuePromise = global[symbolPromise].resolve(0);\n                }\n            }\n            if (nativeMicroTaskQueuePromise) {\n                let nativeThen = nativeMicroTaskQueuePromise[symbolThen];\n                if (!nativeThen) {\n                    // native Promise is not patchable, we need to use `then` directly\n                    // issue 1078\n                    nativeThen = nativeMicroTaskQueuePromise['then'];\n                }\n                nativeThen.call(nativeMicroTaskQueuePromise, drainMicroTaskQueue);\n            }\n            else {\n                global[symbolSetTimeout](drainMicroTaskQueue, 0);\n            }\n        }\n        task && _microTaskQueue.push(task);\n    }\n    function drainMicroTaskQueue() {\n        if (!_isDrainingMicrotaskQueue) {\n            _isDrainingMicrotaskQueue = true;\n            while (_microTaskQueue.length) {\n                const queue = _microTaskQueue;\n                _microTaskQueue = [];\n                for (let i = 0; i < queue.length; i++) {\n                    const task = queue[i];\n                    try {\n                        task.zone.runTask(task, null, null);\n                    }\n                    catch (error) {\n                        _api.onUnhandledError(error);\n                    }\n                }\n            }\n            _api.microtaskDrainDone();\n            _isDrainingMicrotaskQueue = false;\n        }\n    }\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    ///  BOOTSTRAP\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    const NO_ZONE = { name: 'NO ZONE' };\n    const notScheduled = 'notScheduled', scheduling = 'scheduling', scheduled = 'scheduled', running = 'running', canceling = 'canceling', unknown = 'unknown';\n    const microTask = 'microTask', macroTask = 'macroTask', eventTask = 'eventTask';\n    const patches = {};\n    const _api = {\n        symbol: __symbol__,\n        currentZoneFrame: () => _currentZoneFrame,\n        onUnhandledError: noop,\n        microtaskDrainDone: noop,\n        scheduleMicroTask: scheduleMicroTask,\n        showUncaughtError: () => !Zone[__symbol__('ignoreConsoleErrorUncaughtError')],\n        patchEventTarget: () => [],\n        patchOnProperties: noop,\n        patchMethod: () => noop,\n        bindArguments: () => [],\n        patchThen: () => noop,\n        patchMacroTask: () => noop,\n        patchEventPrototype: () => noop,\n        isIEOrEdge: () => false,\n        getGlobalObjects: () => undefined,\n        ObjectDefineProperty: () => noop,\n        ObjectGetOwnPropertyDescriptor: () => undefined,\n        ObjectCreate: () => undefined,\n        ArraySlice: () => [],\n        patchClass: () => noop,\n        wrapWithCurrentZone: () => noop,\n        filterProperties: () => [],\n        attachOriginToPatched: () => noop,\n        _redefineProperty: () => noop,\n        patchCallbacks: () => noop\n    };\n    let _currentZoneFrame = { parent: null, zone: new Zone(null, null) };\n    let _currentTask = null;\n    let _numberOfNestedTaskFrames = 0;\n    function noop() { }\n    performanceMeasure('Zone', 'Zone');\n    return global['Zone'] = Zone;\n})(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Suppress closure compiler errors about unknown 'Zone' variable\n * @fileoverview\n * @suppress {undefinedVars,globalThis,missingRequire}\n */\n/// <reference types=\"node\"/>\n// issue #989, to reduce bundle size, use short name\n/** Object.getOwnPropertyDescriptor */\nconst ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n/** Object.defineProperty */\nconst ObjectDefineProperty = Object.defineProperty;\n/** Object.getPrototypeOf */\nconst ObjectGetPrototypeOf = Object.getPrototypeOf;\n/** Object.create */\nconst ObjectCreate = Object.create;\n/** Array.prototype.slice */\nconst ArraySlice = Array.prototype.slice;\n/** addEventListener string const */\nconst ADD_EVENT_LISTENER_STR = 'addEventListener';\n/** removeEventListener string const */\nconst REMOVE_EVENT_LISTENER_STR = 'removeEventListener';\n/** zoneSymbol addEventListener */\nconst ZONE_SYMBOL_ADD_EVENT_LISTENER = Zone.__symbol__(ADD_EVENT_LISTENER_STR);\n/** zoneSymbol removeEventListener */\nconst ZONE_SYMBOL_REMOVE_EVENT_LISTENER = Zone.__symbol__(REMOVE_EVENT_LISTENER_STR);\n/** true string const */\nconst TRUE_STR = 'true';\n/** false string const */\nconst FALSE_STR = 'false';\n/** Zone symbol prefix string const. */\nconst ZONE_SYMBOL_PREFIX = Zone.__symbol__('');\nfunction wrapWithCurrentZone(callback, source) {\n    return Zone.current.wrap(callback, source);\n}\nfunction scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {\n    return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);\n}\nconst zoneSymbol = Zone.__symbol__;\nconst isWindowExists = typeof window !== 'undefined';\nconst internalWindow = isWindowExists ? window : undefined;\nconst _global = isWindowExists && internalWindow || typeof self === 'object' && self || global;\nconst REMOVE_ATTRIBUTE = 'removeAttribute';\nconst NULL_ON_PROP_VALUE = [null];\nfunction bindArguments(args, source) {\n    for (let i = args.length - 1; i >= 0; i--) {\n        if (typeof args[i] === 'function') {\n            args[i] = wrapWithCurrentZone(args[i], source + '_' + i);\n        }\n    }\n    return args;\n}\nfunction patchPrototype(prototype, fnNames) {\n    const source = prototype.constructor['name'];\n    for (let i = 0; i < fnNames.length; i++) {\n        const name = fnNames[i];\n        const delegate = prototype[name];\n        if (delegate) {\n            const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name);\n            if (!isPropertyWritable(prototypeDesc)) {\n                continue;\n            }\n            prototype[name] = ((delegate) => {\n                const patched = function () {\n                    return delegate.apply(this, bindArguments(arguments, source + '.' + name));\n                };\n                attachOriginToPatched(patched, delegate);\n                return patched;\n            })(delegate);\n        }\n    }\n}\nfunction isPropertyWritable(propertyDesc) {\n    if (!propertyDesc) {\n        return true;\n    }\n    if (propertyDesc.writable === false) {\n        return false;\n    }\n    return !(typeof propertyDesc.get === 'function' && typeof propertyDesc.set === 'undefined');\n}\nconst isWebWorker = (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope);\n// Make sure to access `process` through `_global` so that WebPack does not accidentally browserify\n// this code.\nconst isNode = (!('nw' in _global) && typeof _global.process !== 'undefined' &&\n    {}.toString.call(_global.process) === '[object process]');\nconst isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow['HTMLElement']);\n// we are in electron of nw, so we are both browser and nodejs\n// Make sure to access `process` through `_global` so that WebPack does not accidentally browserify\n// this code.\nconst isMix = typeof _global.process !== 'undefined' &&\n    {}.toString.call(_global.process) === '[object process]' && !isWebWorker &&\n    !!(isWindowExists && internalWindow['HTMLElement']);\nconst zoneSymbolEventNames = {};\nconst wrapFn = function (event) {\n    // https://github.com/angular/zone.js/issues/911, in IE, sometimes\n    // event will be undefined, so we need to use window.event\n    event = event || _global.event;\n    if (!event) {\n        return;\n    }\n    let eventNameSymbol = zoneSymbolEventNames[event.type];\n    if (!eventNameSymbol) {\n        eventNameSymbol = zoneSymbolEventNames[event.type] = zoneSymbol('ON_PROPERTY' + event.type);\n    }\n    const target = this || event.target || _global;\n    const listener = target[eventNameSymbol];\n    let result;\n    if (isBrowser && target === internalWindow && event.type === 'error') {\n        // window.onerror have different signiture\n        // https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror#window.onerror\n        // and onerror callback will prevent default when callback return true\n        const errorEvent = event;\n        result = listener &&\n            listener.call(this, errorEvent.message, errorEvent.filename, errorEvent.lineno, errorEvent.colno, errorEvent.error);\n        if (result === true) {\n            event.preventDefault();\n        }\n    }\n    else {\n        result = listener && listener.apply(this, arguments);\n        if (result != undefined && !result) {\n            event.preventDefault();\n        }\n    }\n    return result;\n};\nfunction patchProperty(obj, prop, prototype) {\n    let desc = ObjectGetOwnPropertyDescriptor(obj, prop);\n    if (!desc && prototype) {\n        // when patch window object, use prototype to check prop exist or not\n        const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);\n        if (prototypeDesc) {\n            desc = { enumerable: true, configurable: true };\n        }\n    }\n    // if the descriptor not exists or is not configurable\n    // just return\n    if (!desc || !desc.configurable) {\n        return;\n    }\n    const onPropPatchedSymbol = zoneSymbol('on' + prop + 'patched');\n    if (obj.hasOwnProperty(onPropPatchedSymbol) && obj[onPropPatchedSymbol]) {\n        return;\n    }\n    // A property descriptor cannot have getter/setter and be writable\n    // deleting the writable and value properties avoids this error:\n    //\n    // TypeError: property descriptors must not specify a value or be writable when a\n    // getter or setter has been specified\n    delete desc.writable;\n    delete desc.value;\n    const originalDescGet = desc.get;\n    const originalDescSet = desc.set;\n    // substr(2) cuz 'onclick' -> 'click', etc\n    const eventName = prop.substr(2);\n    let eventNameSymbol = zoneSymbolEventNames[eventName];\n    if (!eventNameSymbol) {\n        eventNameSymbol = zoneSymbolEventNames[eventName] = zoneSymbol('ON_PROPERTY' + eventName);\n    }\n    desc.set = function (newValue) {\n        // in some of windows's onproperty callback, this is undefined\n        // so we need to check it\n        let target = this;\n        if (!target && obj === _global) {\n            target = _global;\n        }\n        if (!target) {\n            return;\n        }\n        let previousValue = target[eventNameSymbol];\n        if (previousValue) {\n            target.removeEventListener(eventName, wrapFn);\n        }\n        // issue #978, when onload handler was added before loading zone.js\n        // we should remove it with originalDescSet\n        if (originalDescSet) {\n            originalDescSet.apply(target, NULL_ON_PROP_VALUE);\n        }\n        if (typeof newValue === 'function') {\n            target[eventNameSymbol] = newValue;\n            target.addEventListener(eventName, wrapFn, false);\n        }\n        else {\n            target[eventNameSymbol] = null;\n        }\n    };\n    // The getter would return undefined for unassigned properties but the default value of an\n    // unassigned property is null\n    desc.get = function () {\n        // in some of windows's onproperty callback, this is undefined\n        // so we need to check it\n        let target = this;\n        if (!target && obj === _global) {\n            target = _global;\n        }\n        if (!target) {\n            return null;\n        }\n        const listener = target[eventNameSymbol];\n        if (listener) {\n            return listener;\n        }\n        else if (originalDescGet) {\n            // result will be null when use inline event attribute,\n            // such as <button onclick=\"func();\">OK</button>\n            // because the onclick function is internal raw uncompiled handler\n            // the onclick will be evaluated when first time event was triggered or\n            // the property is accessed, https://github.com/angular/zone.js/issues/525\n            // so we should use original native get to retrieve the handler\n            let value = originalDescGet && originalDescGet.call(this);\n            if (value) {\n                desc.set.call(this, value);\n                if (typeof target[REMOVE_ATTRIBUTE] === 'function') {\n                    target.removeAttribute(prop);\n                }\n                return value;\n            }\n        }\n        return null;\n    };\n    ObjectDefineProperty(obj, prop, desc);\n    obj[onPropPatchedSymbol] = true;\n}\nfunction patchOnProperties(obj, properties, prototype) {\n    if (properties) {\n        for (let i = 0; i < properties.length; i++) {\n            patchProperty(obj, 'on' + properties[i], prototype);\n        }\n    }\n    else {\n        const onProperties = [];\n        for (const prop in obj) {\n            if (prop.substr(0, 2) == 'on') {\n                onProperties.push(prop);\n            }\n        }\n        for (let j = 0; j < onProperties.length; j++) {\n            patchProperty(obj, onProperties[j], prototype);\n        }\n    }\n}\nconst originalInstanceKey = zoneSymbol('originalInstance');\n// wrap some native API on `window`\nfunction patchClass(className) {\n    const OriginalClass = _global[className];\n    if (!OriginalClass)\n        return;\n    // keep original class in global\n    _global[zoneSymbol(className)] = OriginalClass;\n    _global[className] = function () {\n        const a = bindArguments(arguments, className);\n        switch (a.length) {\n            case 0:\n                this[originalInstanceKey] = new OriginalClass();\n                break;\n            case 1:\n                this[originalInstanceKey] = new OriginalClass(a[0]);\n                break;\n            case 2:\n                this[originalInstanceKey] = new OriginalClass(a[0], a[1]);\n                break;\n            case 3:\n                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);\n                break;\n            case 4:\n                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);\n                break;\n            default:\n                throw new Error('Arg list too long.');\n        }\n    };\n    // attach original delegate to patched function\n    attachOriginToPatched(_global[className], OriginalClass);\n    const instance = new OriginalClass(function () { });\n    let prop;\n    for (prop in instance) {\n        // https://bugs.webkit.org/show_bug.cgi?id=44721\n        if (className === 'XMLHttpRequest' && prop === 'responseBlob')\n            continue;\n        (function (prop) {\n            if (typeof instance[prop] === 'function') {\n                _global[className].prototype[prop] = function () {\n                    return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);\n                };\n            }\n            else {\n                ObjectDefineProperty(_global[className].prototype, prop, {\n                    set: function (fn) {\n                        if (typeof fn === 'function') {\n                            this[originalInstanceKey][prop] = wrapWithCurrentZone(fn, className + '.' + prop);\n                            // keep callback in wrapped function so we can\n                            // use it in Function.prototype.toString to return\n                            // the native one.\n                            attachOriginToPatched(this[originalInstanceKey][prop], fn);\n                        }\n                        else {\n                            this[originalInstanceKey][prop] = fn;\n                        }\n                    },\n                    get: function () {\n                        return this[originalInstanceKey][prop];\n                    }\n                });\n            }\n        }(prop));\n    }\n    for (prop in OriginalClass) {\n        if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {\n            _global[className][prop] = OriginalClass[prop];\n        }\n    }\n}\nfunction patchMethod(target, name, patchFn) {\n    let proto = target;\n    while (proto && !proto.hasOwnProperty(name)) {\n        proto = ObjectGetPrototypeOf(proto);\n    }\n    if (!proto && target[name]) {\n        // somehow we did not find it, but we can see it. This happens on IE for Window properties.\n        proto = target;\n    }\n    const delegateName = zoneSymbol(name);\n    let delegate = null;\n    if (proto && (!(delegate = proto[delegateName]) || !proto.hasOwnProperty(delegateName))) {\n        delegate = proto[delegateName] = proto[name];\n        // check whether proto[name] is writable\n        // some property is readonly in safari, such as HtmlCanvasElement.prototype.toBlob\n        const desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);\n        if (isPropertyWritable(desc)) {\n            const patchDelegate = patchFn(delegate, delegateName, name);\n            proto[name] = function () {\n                return patchDelegate(this, arguments);\n            };\n            attachOriginToPatched(proto[name], delegate);\n        }\n    }\n    return delegate;\n}\n// TODO: @JiaLiPassion, support cancel task later if necessary\nfunction patchMacroTask(obj, funcName, metaCreator) {\n    let setNative = null;\n    function scheduleTask(task) {\n        const data = task.data;\n        data.args[data.cbIdx] = function () {\n            task.invoke.apply(this, arguments);\n        };\n        setNative.apply(data.target, data.args);\n        return task;\n    }\n    setNative = patchMethod(obj, funcName, (delegate) => function (self, args) {\n        const meta = metaCreator(self, args);\n        if (meta.cbIdx >= 0 && typeof args[meta.cbIdx] === 'function') {\n            return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask);\n        }\n        else {\n            // cause an error by calling it directly.\n            return delegate.apply(self, args);\n        }\n    });\n}\nfunction attachOriginToPatched(patched, original) {\n    patched[zoneSymbol('OriginalDelegate')] = original;\n}\nlet isDetectedIEOrEdge = false;\nlet ieOrEdge = false;\nfunction isIE() {\n    try {\n        const ua = internalWindow.navigator.userAgent;\n        if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1) {\n            return true;\n        }\n    }\n    catch (error) {\n    }\n    return false;\n}\nfunction isIEOrEdge() {\n    if (isDetectedIEOrEdge) {\n        return ieOrEdge;\n    }\n    isDetectedIEOrEdge = true;\n    try {\n        const ua = internalWindow.navigator.userAgent;\n        if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1 || ua.indexOf('Edge/') !== -1) {\n            ieOrEdge = true;\n        }\n    }\n    catch (error) {\n    }\n    return ieOrEdge;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nZone.__load_patch('ZoneAwarePromise', (global, Zone, api) => {\n    const ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    const ObjectDefineProperty = Object.defineProperty;\n    function readableObjectToString(obj) {\n        if (obj && obj.toString === Object.prototype.toString) {\n            const className = obj.constructor && obj.constructor.name;\n            return (className ? className : '') + ': ' + JSON.stringify(obj);\n        }\n        return obj ? obj.toString() : Object.prototype.toString.call(obj);\n    }\n    const __symbol__ = api.symbol;\n    const _uncaughtPromiseErrors = [];\n    const isDisableWrappingUncaughtPromiseRejection = global[__symbol__('DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION')] === true;\n    const symbolPromise = __symbol__('Promise');\n    const symbolThen = __symbol__('then');\n    const creationTrace = '__creationTrace__';\n    api.onUnhandledError = (e) => {\n        if (api.showUncaughtError()) {\n            const rejection = e && e.rejection;\n            if (rejection) {\n                console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task && e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);\n            }\n            else {\n                console.error(e);\n            }\n        }\n    };\n    api.microtaskDrainDone = () => {\n        while (_uncaughtPromiseErrors.length) {\n            const uncaughtPromiseError = _uncaughtPromiseErrors.shift();\n            try {\n                uncaughtPromiseError.zone.runGuarded(() => {\n                    if (uncaughtPromiseError.throwOriginal) {\n                        throw uncaughtPromiseError.rejection;\n                    }\n                    throw uncaughtPromiseError;\n                });\n            }\n            catch (error) {\n                handleUnhandledRejection(error);\n            }\n        }\n    };\n    const UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__('unhandledPromiseRejectionHandler');\n    function handleUnhandledRejection(e) {\n        api.onUnhandledError(e);\n        try {\n            const handler = Zone[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];\n            if (typeof handler === 'function') {\n                handler.call(this, e);\n            }\n        }\n        catch (err) {\n        }\n    }\n    function isThenable(value) {\n        return value && value.then;\n    }\n    function forwardResolution(value) {\n        return value;\n    }\n    function forwardRejection(rejection) {\n        return ZoneAwarePromise.reject(rejection);\n    }\n    const symbolState = __symbol__('state');\n    const symbolValue = __symbol__('value');\n    const symbolFinally = __symbol__('finally');\n    const symbolParentPromiseValue = __symbol__('parentPromiseValue');\n    const symbolParentPromiseState = __symbol__('parentPromiseState');\n    const source = 'Promise.then';\n    const UNRESOLVED = null;\n    const RESOLVED = true;\n    const REJECTED = false;\n    const REJECTED_NO_CATCH = 0;\n    function makeResolver(promise, state) {\n        return (v) => {\n            try {\n                resolvePromise(promise, state, v);\n            }\n            catch (err) {\n                resolvePromise(promise, false, err);\n            }\n            // Do not return value or you will break the Promise spec.\n        };\n    }\n    const once = function () {\n        let wasCalled = false;\n        return function wrapper(wrappedFunction) {\n            return function () {\n                if (wasCalled) {\n                    return;\n                }\n                wasCalled = true;\n                wrappedFunction.apply(null, arguments);\n            };\n        };\n    };\n    const TYPE_ERROR = 'Promise resolved with itself';\n    const CURRENT_TASK_TRACE_SYMBOL = __symbol__('currentTaskTrace');\n    // Promise Resolution\n    function resolvePromise(promise, state, value) {\n        const onceWrapper = once();\n        if (promise === value) {\n            throw new TypeError(TYPE_ERROR);\n        }\n        if (promise[symbolState] === UNRESOLVED) {\n            // should only get value.then once based on promise spec.\n            let then = null;\n            try {\n                if (typeof value === 'object' || typeof value === 'function') {\n                    then = value && value.then;\n                }\n            }\n            catch (err) {\n                onceWrapper(() => {\n                    resolvePromise(promise, false, err);\n                })();\n                return promise;\n            }\n            // if (value instanceof ZoneAwarePromise) {\n            if (state !== REJECTED && value instanceof ZoneAwarePromise &&\n                value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) &&\n                value[symbolState] !== UNRESOLVED) {\n                clearRejectedNoCatch(value);\n                resolvePromise(promise, value[symbolState], value[symbolValue]);\n            }\n            else if (state !== REJECTED && typeof then === 'function') {\n                try {\n                    then.call(value, onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false)));\n                }\n                catch (err) {\n                    onceWrapper(() => {\n                        resolvePromise(promise, false, err);\n                    })();\n                }\n            }\n            else {\n                promise[symbolState] = state;\n                const queue = promise[symbolValue];\n                promise[symbolValue] = value;\n                if (promise[symbolFinally] === symbolFinally) {\n                    // the promise is generated by Promise.prototype.finally\n                    if (state === RESOLVED) {\n                        // the state is resolved, should ignore the value\n                        // and use parent promise value\n                        promise[symbolState] = promise[symbolParentPromiseState];\n                        promise[symbolValue] = promise[symbolParentPromiseValue];\n                    }\n                }\n                // record task information in value when error occurs, so we can\n                // do some additional work such as render longStackTrace\n                if (state === REJECTED && value instanceof Error) {\n                    // check if longStackTraceZone is here\n                    const trace = Zone.currentTask && Zone.currentTask.data &&\n                        Zone.currentTask.data[creationTrace];\n                    if (trace) {\n                        // only keep the long stack trace into error when in longStackTraceZone\n                        ObjectDefineProperty(value, CURRENT_TASK_TRACE_SYMBOL, { configurable: true, enumerable: false, writable: true, value: trace });\n                    }\n                }\n                for (let i = 0; i < queue.length;) {\n                    scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);\n                }\n                if (queue.length == 0 && state == REJECTED) {\n                    promise[symbolState] = REJECTED_NO_CATCH;\n                    let uncaughtPromiseError = value;\n                    try {\n                        // Here we throws a new Error to print more readable error log\n                        // and if the value is not an error, zone.js builds an `Error`\n                        // Object here to attach the stack information.\n                        throw new Error('Uncaught (in promise): ' + readableObjectToString(value) +\n                            (value && value.stack ? '\\n' + value.stack : ''));\n                    }\n                    catch (err) {\n                        uncaughtPromiseError = err;\n                    }\n                    if (isDisableWrappingUncaughtPromiseRejection) {\n                        // If disable wrapping uncaught promise reject\n                        // use the value instead of wrapping it.\n                        uncaughtPromiseError.throwOriginal = true;\n                    }\n                    uncaughtPromiseError.rejection = value;\n                    uncaughtPromiseError.promise = promise;\n                    uncaughtPromiseError.zone = Zone.current;\n                    uncaughtPromiseError.task = Zone.currentTask;\n                    _uncaughtPromiseErrors.push(uncaughtPromiseError);\n                    api.scheduleMicroTask(); // to make sure that it is running\n                }\n            }\n        }\n        // Resolving an already resolved promise is a noop.\n        return promise;\n    }\n    const REJECTION_HANDLED_HANDLER = __symbol__('rejectionHandledHandler');\n    function clearRejectedNoCatch(promise) {\n        if (promise[symbolState] === REJECTED_NO_CATCH) {\n            // if the promise is rejected no catch status\n            // and queue.length > 0, means there is a error handler\n            // here to handle the rejected promise, we should trigger\n            // windows.rejectionhandled eventHandler or nodejs rejectionHandled\n            // eventHandler\n            try {\n                const handler = Zone[REJECTION_HANDLED_HANDLER];\n                if (handler && typeof handler === 'function') {\n                    handler.call(this, { rejection: promise[symbolValue], promise: promise });\n                }\n            }\n            catch (err) {\n            }\n            promise[symbolState] = REJECTED;\n            for (let i = 0; i < _uncaughtPromiseErrors.length; i++) {\n                if (promise === _uncaughtPromiseErrors[i].promise) {\n                    _uncaughtPromiseErrors.splice(i, 1);\n                }\n            }\n        }\n    }\n    function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {\n        clearRejectedNoCatch(promise);\n        const promiseState = promise[symbolState];\n        const delegate = promiseState ?\n            (typeof onFulfilled === 'function') ? onFulfilled : forwardResolution :\n            (typeof onRejected === 'function') ? onRejected : forwardRejection;\n        zone.scheduleMicroTask(source, () => {\n            try {\n                const parentPromiseValue = promise[symbolValue];\n                const isFinallyPromise = !!chainPromise && symbolFinally === chainPromise[symbolFinally];\n                if (isFinallyPromise) {\n                    // if the promise is generated from finally call, keep parent promise's state and value\n                    chainPromise[symbolParentPromiseValue] = parentPromiseValue;\n                    chainPromise[symbolParentPromiseState] = promiseState;\n                }\n                // should not pass value to finally callback\n                const value = zone.run(delegate, undefined, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution ?\n                    [] :\n                    [parentPromiseValue]);\n                resolvePromise(chainPromise, true, value);\n            }\n            catch (error) {\n                // if error occurs, should always return this error\n                resolvePromise(chainPromise, false, error);\n            }\n        }, chainPromise);\n    }\n    const ZONE_AWARE_PROMISE_TO_STRING = 'function ZoneAwarePromise() { [native code] }';\n    const noop = function () { };\n    class ZoneAwarePromise {\n        static toString() {\n            return ZONE_AWARE_PROMISE_TO_STRING;\n        }\n        static resolve(value) {\n            return resolvePromise(new this(null), RESOLVED, value);\n        }\n        static reject(error) {\n            return resolvePromise(new this(null), REJECTED, error);\n        }\n        static race(values) {\n            let resolve;\n            let reject;\n            let promise = new this((res, rej) => {\n                resolve = res;\n                reject = rej;\n            });\n            function onResolve(value) {\n                resolve(value);\n            }\n            function onReject(error) {\n                reject(error);\n            }\n            for (let value of values) {\n                if (!isThenable(value)) {\n                    value = this.resolve(value);\n                }\n                value.then(onResolve, onReject);\n            }\n            return promise;\n        }\n        static all(values) {\n            return ZoneAwarePromise.allWithCallback(values);\n        }\n        static allSettled(values) {\n            const P = this && this.prototype instanceof ZoneAwarePromise ? this : ZoneAwarePromise;\n            return P.allWithCallback(values, {\n                thenCallback: (value) => ({ status: 'fulfilled', value }),\n                errorCallback: (err) => ({ status: 'rejected', reason: err })\n            });\n        }\n        static allWithCallback(values, callback) {\n            let resolve;\n            let reject;\n            let promise = new this((res, rej) => {\n                resolve = res;\n                reject = rej;\n            });\n            // Start at 2 to prevent prematurely resolving if .then is called immediately.\n            let unresolvedCount = 2;\n            let valueIndex = 0;\n            const resolvedValues = [];\n            for (let value of values) {\n                if (!isThenable(value)) {\n                    value = this.resolve(value);\n                }\n                const curValueIndex = valueIndex;\n                try {\n                    value.then((value) => {\n                        resolvedValues[curValueIndex] = callback ? callback.thenCallback(value) : value;\n                        unresolvedCount--;\n                        if (unresolvedCount === 0) {\n                            resolve(resolvedValues);\n                        }\n                    }, (err) => {\n                        if (!callback) {\n                            reject(err);\n                        }\n                        else {\n                            resolvedValues[curValueIndex] = callback.errorCallback(err);\n                            unresolvedCount--;\n                            if (unresolvedCount === 0) {\n                                resolve(resolvedValues);\n                            }\n                        }\n                    });\n                }\n                catch (thenErr) {\n                    reject(thenErr);\n                }\n                unresolvedCount++;\n                valueIndex++;\n            }\n            // Make the unresolvedCount zero-based again.\n            unresolvedCount -= 2;\n            if (unresolvedCount === 0) {\n                resolve(resolvedValues);\n            }\n            return promise;\n        }\n        constructor(executor) {\n            const promise = this;\n            if (!(promise instanceof ZoneAwarePromise)) {\n                throw new Error('Must be an instanceof Promise.');\n            }\n            promise[symbolState] = UNRESOLVED;\n            promise[symbolValue] = []; // queue;\n            try {\n                executor && executor(makeResolver(promise, RESOLVED), makeResolver(promise, REJECTED));\n            }\n            catch (error) {\n                resolvePromise(promise, false, error);\n            }\n        }\n        get [Symbol.toStringTag]() {\n            return 'Promise';\n        }\n        get [Symbol.species]() {\n            return ZoneAwarePromise;\n        }\n        then(onFulfilled, onRejected) {\n            let C = this.constructor[Symbol.species];\n            if (!C || typeof C !== 'function') {\n                C = this.constructor || ZoneAwarePromise;\n            }\n            const chainPromise = new C(noop);\n            const zone = Zone.current;\n            if (this[symbolState] == UNRESOLVED) {\n                this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);\n            }\n            else {\n                scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);\n            }\n            return chainPromise;\n        }\n        catch(onRejected) {\n            return this.then(null, onRejected);\n        }\n        finally(onFinally) {\n            let C = this.constructor[Symbol.species];\n            if (!C || typeof C !== 'function') {\n                C = ZoneAwarePromise;\n            }\n            const chainPromise = new C(noop);\n            chainPromise[symbolFinally] = symbolFinally;\n            const zone = Zone.current;\n            if (this[symbolState] == UNRESOLVED) {\n                this[symbolValue].push(zone, chainPromise, onFinally, onFinally);\n            }\n            else {\n                scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);\n            }\n            return chainPromise;\n        }\n    }\n    // Protect against aggressive optimizers dropping seemingly unused properties.\n    // E.g. Closure Compiler in advanced mode.\n    ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;\n    ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;\n    ZoneAwarePromise['race'] = ZoneAwarePromise.race;\n    ZoneAwarePromise['all'] = ZoneAwarePromise.all;\n    const NativePromise = global[symbolPromise] = global['Promise'];\n    global['Promise'] = ZoneAwarePromise;\n    const symbolThenPatched = __symbol__('thenPatched');\n    function patchThen(Ctor) {\n        const proto = Ctor.prototype;\n        const prop = ObjectGetOwnPropertyDescriptor(proto, 'then');\n        if (prop && (prop.writable === false || !prop.configurable)) {\n            // check Ctor.prototype.then propertyDescriptor is writable or not\n            // in meteor env, writable is false, we should ignore such case\n            return;\n        }\n        const originalThen = proto.then;\n        // Keep a reference to the original method.\n        proto[symbolThen] = originalThen;\n        Ctor.prototype.then = function (onResolve, onReject) {\n            const wrapped = new ZoneAwarePromise((resolve, reject) => {\n                originalThen.call(this, resolve, reject);\n            });\n            return wrapped.then(onResolve, onReject);\n        };\n        Ctor[symbolThenPatched] = true;\n    }\n    api.patchThen = patchThen;\n    function zoneify(fn) {\n        return function (self, args) {\n            let resultPromise = fn.apply(self, args);\n            if (resultPromise instanceof ZoneAwarePromise) {\n                return resultPromise;\n            }\n            let ctor = resultPromise.constructor;\n            if (!ctor[symbolThenPatched]) {\n                patchThen(ctor);\n            }\n            return resultPromise;\n        };\n    }\n    if (NativePromise) {\n        patchThen(NativePromise);\n        patchMethod(global, 'fetch', delegate => zoneify(delegate));\n    }\n    // This is not part of public API, but it is useful for tests, so we expose it.\n    Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;\n    return ZoneAwarePromise;\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// override Function.prototype.toString to make zone.js patched function\n// look like native function\nZone.__load_patch('toString', (global) => {\n    // patch Func.prototype.toString to let them look like native\n    const originalFunctionToString = Function.prototype.toString;\n    const ORIGINAL_DELEGATE_SYMBOL = zoneSymbol('OriginalDelegate');\n    const PROMISE_SYMBOL = zoneSymbol('Promise');\n    const ERROR_SYMBOL = zoneSymbol('Error');\n    const newFunctionToString = function toString() {\n        if (typeof this === 'function') {\n            const originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];\n            if (originalDelegate) {\n                if (typeof originalDelegate === 'function') {\n                    return originalFunctionToString.call(originalDelegate);\n                }\n                else {\n                    return Object.prototype.toString.call(originalDelegate);\n                }\n            }\n            if (this === Promise) {\n                const nativePromise = global[PROMISE_SYMBOL];\n                if (nativePromise) {\n                    return originalFunctionToString.call(nativePromise);\n                }\n            }\n            if (this === Error) {\n                const nativeError = global[ERROR_SYMBOL];\n                if (nativeError) {\n                    return originalFunctionToString.call(nativeError);\n                }\n            }\n        }\n        return originalFunctionToString.call(this);\n    };\n    newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;\n    Function.prototype.toString = newFunctionToString;\n    // patch Object.prototype.toString to let them look like native\n    const originalObjectToString = Object.prototype.toString;\n    const PROMISE_OBJECT_TO_STRING = '[object Promise]';\n    Object.prototype.toString = function () {\n        if (typeof Promise === 'function' && this instanceof Promise) {\n            return PROMISE_OBJECT_TO_STRING;\n        }\n        return originalObjectToString.call(this);\n    };\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet passiveSupported = false;\nif (typeof window !== 'undefined') {\n    try {\n        const options = Object.defineProperty({}, 'passive', {\n            get: function () {\n                passiveSupported = true;\n            }\n        });\n        window.addEventListener('test', options, options);\n        window.removeEventListener('test', options, options);\n    }\n    catch (err) {\n        passiveSupported = false;\n    }\n}\n// an identifier to tell ZoneTask do not create a new invoke closure\nconst OPTIMIZED_ZONE_EVENT_TASK_DATA = {\n    useG: true\n};\nconst zoneSymbolEventNames$1 = {};\nconst globalSources = {};\nconst EVENT_NAME_SYMBOL_REGX = new RegExp('^' + ZONE_SYMBOL_PREFIX + '(\\\\w+)(true|false)$');\nconst IMMEDIATE_PROPAGATION_SYMBOL = zoneSymbol('propagationStopped');\nfunction prepareEventNames(eventName, eventNameToString) {\n    const falseEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + FALSE_STR;\n    const trueEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + TRUE_STR;\n    const symbol = ZONE_SYMBOL_PREFIX + falseEventName;\n    const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\n    zoneSymbolEventNames$1[eventName] = {};\n    zoneSymbolEventNames$1[eventName][FALSE_STR] = symbol;\n    zoneSymbolEventNames$1[eventName][TRUE_STR] = symbolCapture;\n}\nfunction patchEventTarget(_global, apis, patchOptions) {\n    const ADD_EVENT_LISTENER = (patchOptions && patchOptions.add) || ADD_EVENT_LISTENER_STR;\n    const REMOVE_EVENT_LISTENER = (patchOptions && patchOptions.rm) || REMOVE_EVENT_LISTENER_STR;\n    const LISTENERS_EVENT_LISTENER = (patchOptions && patchOptions.listeners) || 'eventListeners';\n    const REMOVE_ALL_LISTENERS_EVENT_LISTENER = (patchOptions && patchOptions.rmAll) || 'removeAllListeners';\n    const zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);\n    const ADD_EVENT_LISTENER_SOURCE = '.' + ADD_EVENT_LISTENER + ':';\n    const PREPEND_EVENT_LISTENER = 'prependListener';\n    const PREPEND_EVENT_LISTENER_SOURCE = '.' + PREPEND_EVENT_LISTENER + ':';\n    const invokeTask = function (task, target, event) {\n        // for better performance, check isRemoved which is set\n        // by removeEventListener\n        if (task.isRemoved) {\n            return;\n        }\n        const delegate = task.callback;\n        if (typeof delegate === 'object' && delegate.handleEvent) {\n            // create the bind version of handleEvent when invoke\n            task.callback = (event) => delegate.handleEvent(event);\n            task.originalDelegate = delegate;\n        }\n        // invoke static task.invoke\n        task.invoke(task, target, [event]);\n        const options = task.options;\n        if (options && typeof options === 'object' && options.once) {\n            // if options.once is true, after invoke once remove listener here\n            // only browser need to do this, nodejs eventEmitter will cal removeListener\n            // inside EventEmitter.once\n            const delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n            target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate, options);\n        }\n    };\n    // global shared zoneAwareCallback to handle all event callback with capture = false\n    const globalZoneAwareCallback = function (event) {\n        // https://github.com/angular/zone.js/issues/911, in IE, sometimes\n        // event will be undefined, so we need to use window.event\n        event = event || _global.event;\n        if (!event) {\n            return;\n        }\n        // event.target is needed for Samsung TV and SourceBuffer\n        // || global is needed https://github.com/angular/zone.js/issues/190\n        const target = this || event.target || _global;\n        const tasks = target[zoneSymbolEventNames$1[event.type][FALSE_STR]];\n        if (tasks) {\n            // invoke all tasks which attached to current target with given event.type and capture = false\n            // for performance concern, if task.length === 1, just invoke\n            if (tasks.length === 1) {\n                invokeTask(tasks[0], target, event);\n            }\n            else {\n                // https://github.com/angular/zone.js/issues/836\n                // copy the tasks array before invoke, to avoid\n                // the callback will remove itself or other listener\n                const copyTasks = tasks.slice();\n                for (let i = 0; i < copyTasks.length; i++) {\n                    if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {\n                        break;\n                    }\n                    invokeTask(copyTasks[i], target, event);\n                }\n            }\n        }\n    };\n    // global shared zoneAwareCallback to handle all event callback with capture = true\n    const globalZoneAwareCaptureCallback = function (event) {\n        // https://github.com/angular/zone.js/issues/911, in IE, sometimes\n        // event will be undefined, so we need to use window.event\n        event = event || _global.event;\n        if (!event) {\n            return;\n        }\n        // event.target is needed for Samsung TV and SourceBuffer\n        // || global is needed https://github.com/angular/zone.js/issues/190\n        const target = this || event.target || _global;\n        const tasks = target[zoneSymbolEventNames$1[event.type][TRUE_STR]];\n        if (tasks) {\n            // invoke all tasks which attached to current target with given event.type and capture = false\n            // for performance concern, if task.length === 1, just invoke\n            if (tasks.length === 1) {\n                invokeTask(tasks[0], target, event);\n            }\n            else {\n                // https://github.com/angular/zone.js/issues/836\n                // copy the tasks array before invoke, to avoid\n                // the callback will remove itself or other listener\n                const copyTasks = tasks.slice();\n                for (let i = 0; i < copyTasks.length; i++) {\n                    if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {\n                        break;\n                    }\n                    invokeTask(copyTasks[i], target, event);\n                }\n            }\n        }\n    };\n    function patchEventTargetMethods(obj, patchOptions) {\n        if (!obj) {\n            return false;\n        }\n        let useGlobalCallback = true;\n        if (patchOptions && patchOptions.useG !== undefined) {\n            useGlobalCallback = patchOptions.useG;\n        }\n        const validateHandler = patchOptions && patchOptions.vh;\n        let checkDuplicate = true;\n        if (patchOptions && patchOptions.chkDup !== undefined) {\n            checkDuplicate = patchOptions.chkDup;\n        }\n        let returnTarget = false;\n        if (patchOptions && patchOptions.rt !== undefined) {\n            returnTarget = patchOptions.rt;\n        }\n        let proto = obj;\n        while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {\n            proto = ObjectGetPrototypeOf(proto);\n        }\n        if (!proto && obj[ADD_EVENT_LISTENER]) {\n            // somehow we did not find it, but we can see it. This happens on IE for Window properties.\n            proto = obj;\n        }\n        if (!proto) {\n            return false;\n        }\n        if (proto[zoneSymbolAddEventListener]) {\n            return false;\n        }\n        const eventNameToString = patchOptions && patchOptions.eventNameToString;\n        // a shared global taskData to pass data for scheduleEventTask\n        // so we do not need to create a new object just for pass some data\n        const taskData = {};\n        const nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];\n        const nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] =\n            proto[REMOVE_EVENT_LISTENER];\n        const nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] =\n            proto[LISTENERS_EVENT_LISTENER];\n        const nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] =\n            proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];\n        let nativePrependEventListener;\n        if (patchOptions && patchOptions.prepend) {\n            nativePrependEventListener = proto[zoneSymbol(patchOptions.prepend)] =\n                proto[patchOptions.prepend];\n        }\n        /**\n         * This util function will build an option object with passive option\n         * to handle all possible input from the user.\n         */\n        function buildEventListenerOptions(options, passive) {\n            if (!passiveSupported && typeof options === 'object' && options) {\n                // doesn't support passive but user want to pass an object as options.\n                // this will not work on some old browser, so we just pass a boolean\n                // as useCapture parameter\n                return !!options.capture;\n            }\n            if (!passiveSupported || !passive) {\n                return options;\n            }\n            if (typeof options === 'boolean') {\n                return { capture: options, passive: true };\n            }\n            if (!options) {\n                return { passive: true };\n            }\n            if (typeof options === 'object' && options.passive !== false) {\n                return Object.assign(Object.assign({}, options), { passive: true });\n            }\n            return options;\n        }\n        const customScheduleGlobal = function (task) {\n            // if there is already a task for the eventName + capture,\n            // just return, because we use the shared globalZoneAwareCallback here.\n            if (taskData.isExisting) {\n                return;\n            }\n            return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);\n        };\n        const customCancelGlobal = function (task) {\n            // if task is not marked as isRemoved, this call is directly\n            // from Zone.prototype.cancelTask, we should remove the task\n            // from tasksList of target first\n            if (!task.isRemoved) {\n                const symbolEventNames = zoneSymbolEventNames$1[task.eventName];\n                let symbolEventName;\n                if (symbolEventNames) {\n                    symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];\n                }\n                const existingTasks = symbolEventName && task.target[symbolEventName];\n                if (existingTasks) {\n                    for (let i = 0; i < existingTasks.length; i++) {\n                        const existingTask = existingTasks[i];\n                        if (existingTask === task) {\n                            existingTasks.splice(i, 1);\n                            // set isRemoved to data for faster invokeTask check\n                            task.isRemoved = true;\n                            if (existingTasks.length === 0) {\n                                // all tasks for the eventName + capture have gone,\n                                // remove globalZoneAwareCallback and remove the task cache from target\n                                task.allRemoved = true;\n                                task.target[symbolEventName] = null;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n            // if all tasks for the eventName + capture have gone,\n            // we will really remove the global event callback,\n            // if not, return\n            if (!task.allRemoved) {\n                return;\n            }\n            return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);\n        };\n        const customScheduleNonGlobal = function (task) {\n            return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);\n        };\n        const customSchedulePrepend = function (task) {\n            return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);\n        };\n        const customCancelNonGlobal = function (task) {\n            return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);\n        };\n        const customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;\n        const customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;\n        const compareTaskCallbackVsDelegate = function (task, delegate) {\n            const typeOfDelegate = typeof delegate;\n            return (typeOfDelegate === 'function' && task.callback === delegate) ||\n                (typeOfDelegate === 'object' && task.originalDelegate === delegate);\n        };\n        const compare = (patchOptions && patchOptions.diff) ? patchOptions.diff : compareTaskCallbackVsDelegate;\n        const unpatchedEvents = Zone[zoneSymbol('UNPATCHED_EVENTS')];\n        const passiveEvents = _global[zoneSymbol('PASSIVE_EVENTS')];\n        const makeAddListener = function (nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget = false, prepend = false) {\n            return function () {\n                const target = this || _global;\n                let eventName = arguments[0];\n                if (patchOptions && patchOptions.transferEventName) {\n                    eventName = patchOptions.transferEventName(eventName);\n                }\n                let delegate = arguments[1];\n                if (!delegate) {\n                    return nativeListener.apply(this, arguments);\n                }\n                if (isNode && eventName === 'uncaughtException') {\n                    // don't patch uncaughtException of nodejs to prevent endless loop\n                    return nativeListener.apply(this, arguments);\n                }\n                // don't create the bind delegate function for handleEvent\n                // case here to improve addEventListener performance\n                // we will create the bind delegate when invoke\n                let isHandleEvent = false;\n                if (typeof delegate !== 'function') {\n                    if (!delegate.handleEvent) {\n                        return nativeListener.apply(this, arguments);\n                    }\n                    isHandleEvent = true;\n                }\n                if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {\n                    return;\n                }\n                const passive = passiveSupported && !!passiveEvents && passiveEvents.indexOf(eventName) !== -1;\n                const options = buildEventListenerOptions(arguments[2], passive);\n                if (unpatchedEvents) {\n                    // check upatched list\n                    for (let i = 0; i < unpatchedEvents.length; i++) {\n                        if (eventName === unpatchedEvents[i]) {\n                            if (passive) {\n                                return nativeListener.call(target, eventName, delegate, options);\n                            }\n                            else {\n                                return nativeListener.apply(this, arguments);\n                            }\n                        }\n                    }\n                }\n                const capture = !options ? false : typeof options === 'boolean' ? true : options.capture;\n                const once = options && typeof options === 'object' ? options.once : false;\n                const zone = Zone.current;\n                let symbolEventNames = zoneSymbolEventNames$1[eventName];\n                if (!symbolEventNames) {\n                    prepareEventNames(eventName, eventNameToString);\n                    symbolEventNames = zoneSymbolEventNames$1[eventName];\n                }\n                const symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\n                let existingTasks = target[symbolEventName];\n                let isExisting = false;\n                if (existingTasks) {\n                    // already have task registered\n                    isExisting = true;\n                    if (checkDuplicate) {\n                        for (let i = 0; i < existingTasks.length; i++) {\n                            if (compare(existingTasks[i], delegate)) {\n                                // same callback, same capture, same event name, just return\n                                return;\n                            }\n                        }\n                    }\n                }\n                else {\n                    existingTasks = target[symbolEventName] = [];\n                }\n                let source;\n                const constructorName = target.constructor['name'];\n                const targetSource = globalSources[constructorName];\n                if (targetSource) {\n                    source = targetSource[eventName];\n                }\n                if (!source) {\n                    source = constructorName + addSource +\n                        (eventNameToString ? eventNameToString(eventName) : eventName);\n                }\n                // do not create a new object as task.data to pass those things\n                // just use the global shared one\n                taskData.options = options;\n                if (once) {\n                    // if addEventListener with once options, we don't pass it to\n                    // native addEventListener, instead we keep the once setting\n                    // and handle ourselves.\n                    taskData.options.once = false;\n                }\n                taskData.target = target;\n                taskData.capture = capture;\n                taskData.eventName = eventName;\n                taskData.isExisting = isExisting;\n                const data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : undefined;\n                // keep taskData into data to allow onScheduleEventTask to access the task information\n                if (data) {\n                    data.taskData = taskData;\n                }\n                const task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);\n                // should clear taskData.target to avoid memory leak\n                // issue, https://github.com/angular/angular/issues/20442\n                taskData.target = null;\n                // need to clear up taskData because it is a global object\n                if (data) {\n                    data.taskData = null;\n                }\n                // have to save those information to task in case\n                // application may call task.zone.cancelTask() directly\n                if (once) {\n                    options.once = true;\n                }\n                if (!(!passiveSupported && typeof task.options === 'boolean')) {\n                    // if not support passive, and we pass an option object\n                    // to addEventListener, we should save the options to task\n                    task.options = options;\n                }\n                task.target = target;\n                task.capture = capture;\n                task.eventName = eventName;\n                if (isHandleEvent) {\n                    // save original delegate for compare to check duplicate\n                    task.originalDelegate = delegate;\n                }\n                if (!prepend) {\n                    existingTasks.push(task);\n                }\n                else {\n                    existingTasks.unshift(task);\n                }\n                if (returnTarget) {\n                    return target;\n                }\n            };\n        };\n        proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);\n        if (nativePrependEventListener) {\n            proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);\n        }\n        proto[REMOVE_EVENT_LISTENER] = function () {\n            const target = this || _global;\n            let eventName = arguments[0];\n            if (patchOptions && patchOptions.transferEventName) {\n                eventName = patchOptions.transferEventName(eventName);\n            }\n            const options = arguments[2];\n            const capture = !options ? false : typeof options === 'boolean' ? true : options.capture;\n            const delegate = arguments[1];\n            if (!delegate) {\n                return nativeRemoveEventListener.apply(this, arguments);\n            }\n            if (validateHandler &&\n                !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {\n                return;\n            }\n            const symbolEventNames = zoneSymbolEventNames$1[eventName];\n            let symbolEventName;\n            if (symbolEventNames) {\n                symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\n            }\n            const existingTasks = symbolEventName && target[symbolEventName];\n            if (existingTasks) {\n                for (let i = 0; i < existingTasks.length; i++) {\n                    const existingTask = existingTasks[i];\n                    if (compare(existingTask, delegate)) {\n                        existingTasks.splice(i, 1);\n                        // set isRemoved to data for faster invokeTask check\n                        existingTask.isRemoved = true;\n                        if (existingTasks.length === 0) {\n                            // all tasks for the eventName + capture have gone,\n                            // remove globalZoneAwareCallback and remove the task cache from target\n                            existingTask.allRemoved = true;\n                            target[symbolEventName] = null;\n                            // in the target, we have an event listener which is added by on_property\n                            // such as target.onclick = function() {}, so we need to clear this internal\n                            // property too if all delegates all removed\n                            if (typeof eventName === 'string') {\n                                const onPropertySymbol = ZONE_SYMBOL_PREFIX + 'ON_PROPERTY' + eventName;\n                                target[onPropertySymbol] = null;\n                            }\n                        }\n                        existingTask.zone.cancelTask(existingTask);\n                        if (returnTarget) {\n                            return target;\n                        }\n                        return;\n                    }\n                }\n            }\n            // issue 930, didn't find the event name or callback\n            // from zone kept existingTasks, the callback maybe\n            // added outside of zone, we need to call native removeEventListener\n            // to try to remove it.\n            return nativeRemoveEventListener.apply(this, arguments);\n        };\n        proto[LISTENERS_EVENT_LISTENER] = function () {\n            const target = this || _global;\n            let eventName = arguments[0];\n            if (patchOptions && patchOptions.transferEventName) {\n                eventName = patchOptions.transferEventName(eventName);\n            }\n            const listeners = [];\n            const tasks = findEventTasks(target, eventNameToString ? eventNameToString(eventName) : eventName);\n            for (let i = 0; i < tasks.length; i++) {\n                const task = tasks[i];\n                let delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n                listeners.push(delegate);\n            }\n            return listeners;\n        };\n        proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function () {\n            const target = this || _global;\n            let eventName = arguments[0];\n            if (!eventName) {\n                const keys = Object.keys(target);\n                for (let i = 0; i < keys.length; i++) {\n                    const prop = keys[i];\n                    const match = EVENT_NAME_SYMBOL_REGX.exec(prop);\n                    let evtName = match && match[1];\n                    // in nodejs EventEmitter, removeListener event is\n                    // used for monitoring the removeListener call,\n                    // so just keep removeListener eventListener until\n                    // all other eventListeners are removed\n                    if (evtName && evtName !== 'removeListener') {\n                        this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);\n                    }\n                }\n                // remove removeListener listener finally\n                this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, 'removeListener');\n            }\n            else {\n                if (patchOptions && patchOptions.transferEventName) {\n                    eventName = patchOptions.transferEventName(eventName);\n                }\n                const symbolEventNames = zoneSymbolEventNames$1[eventName];\n                if (symbolEventNames) {\n                    const symbolEventName = symbolEventNames[FALSE_STR];\n                    const symbolCaptureEventName = symbolEventNames[TRUE_STR];\n                    const tasks = target[symbolEventName];\n                    const captureTasks = target[symbolCaptureEventName];\n                    if (tasks) {\n                        const removeTasks = tasks.slice();\n                        for (let i = 0; i < removeTasks.length; i++) {\n                            const task = removeTasks[i];\n                            let delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n                            this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);\n                        }\n                    }\n                    if (captureTasks) {\n                        const removeTasks = captureTasks.slice();\n                        for (let i = 0; i < removeTasks.length; i++) {\n                            const task = removeTasks[i];\n                            let delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n                            this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);\n                        }\n                    }\n                }\n            }\n            if (returnTarget) {\n                return this;\n            }\n        };\n        // for native toString patch\n        attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);\n        attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);\n        if (nativeRemoveAllListeners) {\n            attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);\n        }\n        if (nativeListeners) {\n            attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);\n        }\n        return true;\n    }\n    let results = [];\n    for (let i = 0; i < apis.length; i++) {\n        results[i] = patchEventTargetMethods(apis[i], patchOptions);\n    }\n    return results;\n}\nfunction findEventTasks(target, eventName) {\n    if (!eventName) {\n        const foundTasks = [];\n        for (let prop in target) {\n            const match = EVENT_NAME_SYMBOL_REGX.exec(prop);\n            let evtName = match && match[1];\n            if (evtName && (!eventName || evtName === eventName)) {\n                const tasks = target[prop];\n                if (tasks) {\n                    for (let i = 0; i < tasks.length; i++) {\n                        foundTasks.push(tasks[i]);\n                    }\n                }\n            }\n        }\n        return foundTasks;\n    }\n    let symbolEventName = zoneSymbolEventNames$1[eventName];\n    if (!symbolEventName) {\n        prepareEventNames(eventName);\n        symbolEventName = zoneSymbolEventNames$1[eventName];\n    }\n    const captureFalseTasks = target[symbolEventName[FALSE_STR]];\n    const captureTrueTasks = target[symbolEventName[TRUE_STR]];\n    if (!captureFalseTasks) {\n        return captureTrueTasks ? captureTrueTasks.slice() : [];\n    }\n    else {\n        return captureTrueTasks ? captureFalseTasks.concat(captureTrueTasks) :\n            captureFalseTasks.slice();\n    }\n}\nfunction patchEventPrototype(global, api) {\n    const Event = global['Event'];\n    if (Event && Event.prototype) {\n        api.patchMethod(Event.prototype, 'stopImmediatePropagation', (delegate) => function (self, args) {\n            self[IMMEDIATE_PROPAGATION_SYMBOL] = true;\n            // we need to call the native stopImmediatePropagation\n            // in case in some hybrid application, some part of\n            // application will be controlled by zone, some are not\n            delegate && delegate.apply(self, args);\n        });\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction patchCallbacks(api, target, targetName, method, callbacks) {\n    const symbol = Zone.__symbol__(method);\n    if (target[symbol]) {\n        return;\n    }\n    const nativeDelegate = target[symbol] = target[method];\n    target[method] = function (name, opts, options) {\n        if (opts && opts.prototype) {\n            callbacks.forEach(function (callback) {\n                const source = `${targetName}.${method}::` + callback;\n                const prototype = opts.prototype;\n                if (prototype.hasOwnProperty(callback)) {\n                    const descriptor = api.ObjectGetOwnPropertyDescriptor(prototype, callback);\n                    if (descriptor && descriptor.value) {\n                        descriptor.value = api.wrapWithCurrentZone(descriptor.value, source);\n                        api._redefineProperty(opts.prototype, callback, descriptor);\n                    }\n                    else if (prototype[callback]) {\n                        prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);\n                    }\n                }\n                else if (prototype[callback]) {\n                    prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);\n                }\n            });\n        }\n        return nativeDelegate.call(target, name, opts, options);\n    };\n    api.attachOriginToPatched(target[method], nativeDelegate);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst globalEventHandlersEventNames = [\n    'abort',\n    'animationcancel',\n    'animationend',\n    'animationiteration',\n    'auxclick',\n    'beforeinput',\n    'blur',\n    'cancel',\n    'canplay',\n    'canplaythrough',\n    'change',\n    'compositionstart',\n    'compositionupdate',\n    'compositionend',\n    'cuechange',\n    'click',\n    'close',\n    'contextmenu',\n    'curechange',\n    'dblclick',\n    'drag',\n    'dragend',\n    'dragenter',\n    'dragexit',\n    'dragleave',\n    'dragover',\n    'drop',\n    'durationchange',\n    'emptied',\n    'ended',\n    'error',\n    'focus',\n    'focusin',\n    'focusout',\n    'gotpointercapture',\n    'input',\n    'invalid',\n    'keydown',\n    'keypress',\n    'keyup',\n    'load',\n    'loadstart',\n    'loadeddata',\n    'loadedmetadata',\n    'lostpointercapture',\n    'mousedown',\n    'mouseenter',\n    'mouseleave',\n    'mousemove',\n    'mouseout',\n    'mouseover',\n    'mouseup',\n    'mousewheel',\n    'orientationchange',\n    'pause',\n    'play',\n    'playing',\n    'pointercancel',\n    'pointerdown',\n    'pointerenter',\n    'pointerleave',\n    'pointerlockchange',\n    'mozpointerlockchange',\n    'webkitpointerlockerchange',\n    'pointerlockerror',\n    'mozpointerlockerror',\n    'webkitpointerlockerror',\n    'pointermove',\n    'pointout',\n    'pointerover',\n    'pointerup',\n    'progress',\n    'ratechange',\n    'reset',\n    'resize',\n    'scroll',\n    'seeked',\n    'seeking',\n    'select',\n    'selectionchange',\n    'selectstart',\n    'show',\n    'sort',\n    'stalled',\n    'submit',\n    'suspend',\n    'timeupdate',\n    'volumechange',\n    'touchcancel',\n    'touchmove',\n    'touchstart',\n    'touchend',\n    'transitioncancel',\n    'transitionend',\n    'waiting',\n    'wheel'\n];\nconst documentEventNames = [\n    'afterscriptexecute', 'beforescriptexecute', 'DOMContentLoaded', 'freeze', 'fullscreenchange',\n    'mozfullscreenchange', 'webkitfullscreenchange', 'msfullscreenchange', 'fullscreenerror',\n    'mozfullscreenerror', 'webkitfullscreenerror', 'msfullscreenerror', 'readystatechange',\n    'visibilitychange', 'resume'\n];\nconst windowEventNames = [\n    'absolutedeviceorientation',\n    'afterinput',\n    'afterprint',\n    'appinstalled',\n    'beforeinstallprompt',\n    'beforeprint',\n    'beforeunload',\n    'devicelight',\n    'devicemotion',\n    'deviceorientation',\n    'deviceorientationabsolute',\n    'deviceproximity',\n    'hashchange',\n    'languagechange',\n    'message',\n    'mozbeforepaint',\n    'offline',\n    'online',\n    'paint',\n    'pageshow',\n    'pagehide',\n    'popstate',\n    'rejectionhandled',\n    'storage',\n    'unhandledrejection',\n    'unload',\n    'userproximity',\n    'vrdisplayconnected',\n    'vrdisplaydisconnected',\n    'vrdisplaypresentchange'\n];\nconst htmlElementEventNames = [\n    'beforecopy', 'beforecut', 'beforepaste', 'copy', 'cut', 'paste', 'dragstart', 'loadend',\n    'animationstart', 'search', 'transitionrun', 'transitionstart', 'webkitanimationend',\n    'webkitanimationiteration', 'webkitanimationstart', 'webkittransitionend'\n];\nconst mediaElementEventNames = ['encrypted', 'waitingforkey', 'msneedkey', 'mozinterruptbegin', 'mozinterruptend'];\nconst ieElementEventNames = [\n    'activate',\n    'afterupdate',\n    'ariarequest',\n    'beforeactivate',\n    'beforedeactivate',\n    'beforeeditfocus',\n    'beforeupdate',\n    'cellchange',\n    'controlselect',\n    'dataavailable',\n    'datasetchanged',\n    'datasetcomplete',\n    'errorupdate',\n    'filterchange',\n    'layoutcomplete',\n    'losecapture',\n    'move',\n    'moveend',\n    'movestart',\n    'propertychange',\n    'resizeend',\n    'resizestart',\n    'rowenter',\n    'rowexit',\n    'rowsdelete',\n    'rowsinserted',\n    'command',\n    'compassneedscalibration',\n    'deactivate',\n    'help',\n    'mscontentzoom',\n    'msmanipulationstatechanged',\n    'msgesturechange',\n    'msgesturedoubletap',\n    'msgestureend',\n    'msgesturehold',\n    'msgesturestart',\n    'msgesturetap',\n    'msgotpointercapture',\n    'msinertiastart',\n    'mslostpointercapture',\n    'mspointercancel',\n    'mspointerdown',\n    'mspointerenter',\n    'mspointerhover',\n    'mspointerleave',\n    'mspointermove',\n    'mspointerout',\n    'mspointerover',\n    'mspointerup',\n    'pointerout',\n    'mssitemodejumplistitemremoved',\n    'msthumbnailclick',\n    'stop',\n    'storagecommit'\n];\nconst webglEventNames = ['webglcontextrestored', 'webglcontextlost', 'webglcontextcreationerror'];\nconst formEventNames = ['autocomplete', 'autocompleteerror'];\nconst detailEventNames = ['toggle'];\nconst frameEventNames = ['load'];\nconst frameSetEventNames = ['blur', 'error', 'focus', 'load', 'resize', 'scroll', 'messageerror'];\nconst marqueeEventNames = ['bounce', 'finish', 'start'];\nconst XMLHttpRequestEventNames = [\n    'loadstart', 'progress', 'abort', 'error', 'load', 'progress', 'timeout', 'loadend',\n    'readystatechange'\n];\nconst IDBIndexEventNames = ['upgradeneeded', 'complete', 'abort', 'success', 'error', 'blocked', 'versionchange', 'close'];\nconst websocketEventNames = ['close', 'error', 'open', 'message'];\nconst workerEventNames = ['error', 'message'];\nconst eventNames = globalEventHandlersEventNames.concat(webglEventNames, formEventNames, detailEventNames, documentEventNames, windowEventNames, htmlElementEventNames, ieElementEventNames);\nfunction filterProperties(target, onProperties, ignoreProperties) {\n    if (!ignoreProperties || ignoreProperties.length === 0) {\n        return onProperties;\n    }\n    const tip = ignoreProperties.filter(ip => ip.target === target);\n    if (!tip || tip.length === 0) {\n        return onProperties;\n    }\n    const targetIgnoreProperties = tip[0].ignoreProperties;\n    return onProperties.filter(op => targetIgnoreProperties.indexOf(op) === -1);\n}\nfunction patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {\n    // check whether target is available, sometimes target will be undefined\n    // because different browser or some 3rd party plugin.\n    if (!target) {\n        return;\n    }\n    const filteredProperties = filterProperties(target, onProperties, ignoreProperties);\n    patchOnProperties(target, filteredProperties, prototype);\n}\nfunction propertyDescriptorPatch(api, _global) {\n    if (isNode && !isMix) {\n        return;\n    }\n    if (Zone[api.symbol('patchEvents')]) {\n        // events are already been patched by legacy patch.\n        return;\n    }\n    const supportsWebSocket = typeof WebSocket !== 'undefined';\n    const ignoreProperties = _global['__Zone_ignore_on_properties'];\n    // for browsers that we can patch the descriptor:  Chrome & Firefox\n    if (isBrowser) {\n        const internalWindow = window;\n        const ignoreErrorProperties = isIE() ? [{ target: internalWindow, ignoreProperties: ['error'] }] : [];\n        // in IE/Edge, onProp not exist in window object, but in WindowPrototype\n        // so we need to pass WindowPrototype to check onProp exist or not\n        patchFilteredProperties(internalWindow, eventNames.concat(['messageerror']), ignoreProperties ? ignoreProperties.concat(ignoreErrorProperties) : ignoreProperties, ObjectGetPrototypeOf(internalWindow));\n        patchFilteredProperties(Document.prototype, eventNames, ignoreProperties);\n        if (typeof internalWindow['SVGElement'] !== 'undefined') {\n            patchFilteredProperties(internalWindow['SVGElement'].prototype, eventNames, ignoreProperties);\n        }\n        patchFilteredProperties(Element.prototype, eventNames, ignoreProperties);\n        patchFilteredProperties(HTMLElement.prototype, eventNames, ignoreProperties);\n        patchFilteredProperties(HTMLMediaElement.prototype, mediaElementEventNames, ignoreProperties);\n        patchFilteredProperties(HTMLFrameSetElement.prototype, windowEventNames.concat(frameSetEventNames), ignoreProperties);\n        patchFilteredProperties(HTMLBodyElement.prototype, windowEventNames.concat(frameSetEventNames), ignoreProperties);\n        patchFilteredProperties(HTMLFrameElement.prototype, frameEventNames, ignoreProperties);\n        patchFilteredProperties(HTMLIFrameElement.prototype, frameEventNames, ignoreProperties);\n        const HTMLMarqueeElement = internalWindow['HTMLMarqueeElement'];\n        if (HTMLMarqueeElement) {\n            patchFilteredProperties(HTMLMarqueeElement.prototype, marqueeEventNames, ignoreProperties);\n        }\n        const Worker = internalWindow['Worker'];\n        if (Worker) {\n            patchFilteredProperties(Worker.prototype, workerEventNames, ignoreProperties);\n        }\n    }\n    const XMLHttpRequest = _global['XMLHttpRequest'];\n    if (XMLHttpRequest) {\n        // XMLHttpRequest is not available in ServiceWorker, so we need to check here\n        patchFilteredProperties(XMLHttpRequest.prototype, XMLHttpRequestEventNames, ignoreProperties);\n    }\n    const XMLHttpRequestEventTarget = _global['XMLHttpRequestEventTarget'];\n    if (XMLHttpRequestEventTarget) {\n        patchFilteredProperties(XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype, XMLHttpRequestEventNames, ignoreProperties);\n    }\n    if (typeof IDBIndex !== 'undefined') {\n        patchFilteredProperties(IDBIndex.prototype, IDBIndexEventNames, ignoreProperties);\n        patchFilteredProperties(IDBRequest.prototype, IDBIndexEventNames, ignoreProperties);\n        patchFilteredProperties(IDBOpenDBRequest.prototype, IDBIndexEventNames, ignoreProperties);\n        patchFilteredProperties(IDBDatabase.prototype, IDBIndexEventNames, ignoreProperties);\n        patchFilteredProperties(IDBTransaction.prototype, IDBIndexEventNames, ignoreProperties);\n        patchFilteredProperties(IDBCursor.prototype, IDBIndexEventNames, ignoreProperties);\n    }\n    if (supportsWebSocket) {\n        patchFilteredProperties(WebSocket.prototype, websocketEventNames, ignoreProperties);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nZone.__load_patch('util', (global, Zone, api) => {\n    api.patchOnProperties = patchOnProperties;\n    api.patchMethod = patchMethod;\n    api.bindArguments = bindArguments;\n    api.patchMacroTask = patchMacroTask;\n    // In earlier version of zone.js (<0.9.0), we use env name `__zone_symbol__BLACK_LISTED_EVENTS` to\n    // define which events will not be patched by `Zone.js`.\n    // In newer version (>=0.9.0), we change the env name to `__zone_symbol__UNPATCHED_EVENTS` to keep\n    // the name consistent with angular repo.\n    // The  `__zone_symbol__BLACK_LISTED_EVENTS` is deprecated, but it is still be supported for\n    // backwards compatibility.\n    const SYMBOL_BLACK_LISTED_EVENTS = Zone.__symbol__('BLACK_LISTED_EVENTS');\n    const SYMBOL_UNPATCHED_EVENTS = Zone.__symbol__('UNPATCHED_EVENTS');\n    if (global[SYMBOL_UNPATCHED_EVENTS]) {\n        global[SYMBOL_BLACK_LISTED_EVENTS] = global[SYMBOL_UNPATCHED_EVENTS];\n    }\n    if (global[SYMBOL_BLACK_LISTED_EVENTS]) {\n        Zone[SYMBOL_BLACK_LISTED_EVENTS] = Zone[SYMBOL_UNPATCHED_EVENTS] =\n            global[SYMBOL_BLACK_LISTED_EVENTS];\n    }\n    api.patchEventPrototype = patchEventPrototype;\n    api.patchEventTarget = patchEventTarget;\n    api.isIEOrEdge = isIEOrEdge;\n    api.ObjectDefineProperty = ObjectDefineProperty;\n    api.ObjectGetOwnPropertyDescriptor = ObjectGetOwnPropertyDescriptor;\n    api.ObjectCreate = ObjectCreate;\n    api.ArraySlice = ArraySlice;\n    api.patchClass = patchClass;\n    api.wrapWithCurrentZone = wrapWithCurrentZone;\n    api.filterProperties = filterProperties;\n    api.attachOriginToPatched = attachOriginToPatched;\n    api._redefineProperty = Object.defineProperty;\n    api.patchCallbacks = patchCallbacks;\n    api.getGlobalObjects = () => ({\n        globalSources,\n        zoneSymbolEventNames: zoneSymbolEventNames$1,\n        eventNames,\n        isBrowser,\n        isMix,\n        isNode,\n        TRUE_STR,\n        FALSE_STR,\n        ZONE_SYMBOL_PREFIX,\n        ADD_EVENT_LISTENER_STR,\n        REMOVE_EVENT_LISTENER_STR\n    });\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst taskSymbol = zoneSymbol('zoneTask');\nfunction patchTimer(window, setName, cancelName, nameSuffix) {\n    let setNative = null;\n    let clearNative = null;\n    setName += nameSuffix;\n    cancelName += nameSuffix;\n    const tasksByHandleId = {};\n    function scheduleTask(task) {\n        const data = task.data;\n        data.args[0] = function () {\n            return task.invoke.apply(this, arguments);\n        };\n        data.handleId = setNative.apply(window, data.args);\n        return task;\n    }\n    function clearTask(task) {\n        return clearNative.call(window, task.data.handleId);\n    }\n    setNative =\n        patchMethod(window, setName, (delegate) => function (self, args) {\n            if (typeof args[0] === 'function') {\n                const options = {\n                    isPeriodic: nameSuffix === 'Interval',\n                    delay: (nameSuffix === 'Timeout' || nameSuffix === 'Interval') ? args[1] || 0 :\n                        undefined,\n                    args: args\n                };\n                const callback = args[0];\n                args[0] = function timer() {\n                    try {\n                        return callback.apply(this, arguments);\n                    }\n                    finally {\n                        // issue-934, task will be cancelled\n                        // even it is a periodic task such as\n                        // setInterval\n                        // https://github.com/angular/angular/issues/40387\n                        // Cleanup tasksByHandleId should be handled before scheduleTask\n                        // Since some zoneSpec may intercept and doesn't trigger\n                        // scheduleFn(scheduleTask) provided here.\n                        if (!(options.isPeriodic)) {\n                            if (typeof options.handleId === 'number') {\n                                // in non-nodejs env, we remove timerId\n                                // from local cache\n                                delete tasksByHandleId[options.handleId];\n                            }\n                            else if (options.handleId) {\n                                // Node returns complex objects as handleIds\n                                // we remove task reference from timer object\n                                options.handleId[taskSymbol] = null;\n                            }\n                        }\n                    }\n                };\n                const task = scheduleMacroTaskWithCurrentZone(setName, args[0], options, scheduleTask, clearTask);\n                if (!task) {\n                    return task;\n                }\n                // Node.js must additionally support the ref and unref functions.\n                const handle = task.data.handleId;\n                if (typeof handle === 'number') {\n                    // for non nodejs env, we save handleId: task\n                    // mapping in local cache for clearTimeout\n                    tasksByHandleId[handle] = task;\n                }\n                else if (handle) {\n                    // for nodejs env, we save task\n                    // reference in timerId Object for clearTimeout\n                    handle[taskSymbol] = task;\n                }\n                // check whether handle is null, because some polyfill or browser\n                // may return undefined from setTimeout/setInterval/setImmediate/requestAnimationFrame\n                if (handle && handle.ref && handle.unref && typeof handle.ref === 'function' &&\n                    typeof handle.unref === 'function') {\n                    task.ref = handle.ref.bind(handle);\n                    task.unref = handle.unref.bind(handle);\n                }\n                if (typeof handle === 'number' || handle) {\n                    return handle;\n                }\n                return task;\n            }\n            else {\n                // cause an error by calling it directly.\n                return delegate.apply(window, args);\n            }\n        });\n    clearNative =\n        patchMethod(window, cancelName, (delegate) => function (self, args) {\n            const id = args[0];\n            let task;\n            if (typeof id === 'number') {\n                // non nodejs env.\n                task = tasksByHandleId[id];\n            }\n            else {\n                // nodejs env.\n                task = id && id[taskSymbol];\n                // other environments.\n                if (!task) {\n                    task = id;\n                }\n            }\n            if (task && typeof task.type === 'string') {\n                if (task.state !== 'notScheduled' &&\n                    (task.cancelFn && task.data.isPeriodic || task.runCount === 0)) {\n                    if (typeof id === 'number') {\n                        delete tasksByHandleId[id];\n                    }\n                    else if (id) {\n                        id[taskSymbol] = null;\n                    }\n                    // Do not cancel already canceled functions\n                    task.zone.cancelTask(task);\n                }\n            }\n            else {\n                // cause an error by calling it directly.\n                delegate.apply(window, args);\n            }\n        });\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction patchCustomElements(_global, api) {\n    const { isBrowser, isMix } = api.getGlobalObjects();\n    if ((!isBrowser && !isMix) || !_global['customElements'] || !('customElements' in _global)) {\n        return;\n    }\n    const callbacks = ['connectedCallback', 'disconnectedCallback', 'adoptedCallback', 'attributeChangedCallback'];\n    api.patchCallbacks(api, _global.customElements, 'customElements', 'define', callbacks);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction eventTargetPatch(_global, api) {\n    if (Zone[api.symbol('patchEventTarget')]) {\n        // EventTarget is already patched.\n        return;\n    }\n    const { eventNames, zoneSymbolEventNames, TRUE_STR, FALSE_STR, ZONE_SYMBOL_PREFIX } = api.getGlobalObjects();\n    //  predefine all __zone_symbol__ + eventName + true/false string\n    for (let i = 0; i < eventNames.length; i++) {\n        const eventName = eventNames[i];\n        const falseEventName = eventName + FALSE_STR;\n        const trueEventName = eventName + TRUE_STR;\n        const symbol = ZONE_SYMBOL_PREFIX + falseEventName;\n        const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\n        zoneSymbolEventNames[eventName] = {};\n        zoneSymbolEventNames[eventName][FALSE_STR] = symbol;\n        zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;\n    }\n    const EVENT_TARGET = _global['EventTarget'];\n    if (!EVENT_TARGET || !EVENT_TARGET.prototype) {\n        return;\n    }\n    api.patchEventTarget(_global, [EVENT_TARGET && EVENT_TARGET.prototype]);\n    return true;\n}\nfunction patchEvent(global, api) {\n    api.patchEventPrototype(global, api);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nZone.__load_patch('legacy', (global) => {\n    const legacyPatch = global[Zone.__symbol__('legacyPatch')];\n    if (legacyPatch) {\n        legacyPatch();\n    }\n});\nZone.__load_patch('queueMicrotask', (global, Zone, api) => {\n    api.patchMethod(global, 'queueMicrotask', delegate => {\n        return function (self, args) {\n            Zone.current.scheduleMicroTask('queueMicrotask', args[0]);\n        };\n    });\n});\nZone.__load_patch('timers', (global) => {\n    const set = 'set';\n    const clear = 'clear';\n    patchTimer(global, set, clear, 'Timeout');\n    patchTimer(global, set, clear, 'Interval');\n    patchTimer(global, set, clear, 'Immediate');\n});\nZone.__load_patch('requestAnimationFrame', (global) => {\n    patchTimer(global, 'request', 'cancel', 'AnimationFrame');\n    patchTimer(global, 'mozRequest', 'mozCancel', 'AnimationFrame');\n    patchTimer(global, 'webkitRequest', 'webkitCancel', 'AnimationFrame');\n});\nZone.__load_patch('blocking', (global, Zone) => {\n    const blockingMethods = ['alert', 'prompt', 'confirm'];\n    for (let i = 0; i < blockingMethods.length; i++) {\n        const name = blockingMethods[i];\n        patchMethod(global, name, (delegate, symbol, name) => {\n            return function (s, args) {\n                return Zone.current.run(delegate, global, args, name);\n            };\n        });\n    }\n});\nZone.__load_patch('EventTarget', (global, Zone, api) => {\n    patchEvent(global, api);\n    eventTargetPatch(global, api);\n    // patch XMLHttpRequestEventTarget's addEventListener/removeEventListener\n    const XMLHttpRequestEventTarget = global['XMLHttpRequestEventTarget'];\n    if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {\n        api.patchEventTarget(global, [XMLHttpRequestEventTarget.prototype]);\n    }\n});\nZone.__load_patch('MutationObserver', (global, Zone, api) => {\n    patchClass('MutationObserver');\n    patchClass('WebKitMutationObserver');\n});\nZone.__load_patch('IntersectionObserver', (global, Zone, api) => {\n    patchClass('IntersectionObserver');\n});\nZone.__load_patch('FileReader', (global, Zone, api) => {\n    patchClass('FileReader');\n});\nZone.__load_patch('on_property', (global, Zone, api) => {\n    propertyDescriptorPatch(api, global);\n});\nZone.__load_patch('customElements', (global, Zone, api) => {\n    patchCustomElements(global, api);\n});\nZone.__load_patch('XHR', (global, Zone) => {\n    // Treat XMLHttpRequest as a macrotask.\n    patchXHR(global);\n    const XHR_TASK = zoneSymbol('xhrTask');\n    const XHR_SYNC = zoneSymbol('xhrSync');\n    const XHR_LISTENER = zoneSymbol('xhrListener');\n    const XHR_SCHEDULED = zoneSymbol('xhrScheduled');\n    const XHR_URL = zoneSymbol('xhrURL');\n    const XHR_ERROR_BEFORE_SCHEDULED = zoneSymbol('xhrErrorBeforeScheduled');\n    function patchXHR(window) {\n        const XMLHttpRequest = window['XMLHttpRequest'];\n        if (!XMLHttpRequest) {\n            // XMLHttpRequest is not available in service worker\n            return;\n        }\n        const XMLHttpRequestPrototype = XMLHttpRequest.prototype;\n        function findPendingTask(target) {\n            return target[XHR_TASK];\n        }\n        let oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n        let oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n        if (!oriAddListener) {\n            const XMLHttpRequestEventTarget = window['XMLHttpRequestEventTarget'];\n            if (XMLHttpRequestEventTarget) {\n                const XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget.prototype;\n                oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n                oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n            }\n        }\n        const READY_STATE_CHANGE = 'readystatechange';\n        const SCHEDULED = 'scheduled';\n        function scheduleTask(task) {\n            const data = task.data;\n            const target = data.target;\n            target[XHR_SCHEDULED] = false;\n            target[XHR_ERROR_BEFORE_SCHEDULED] = false;\n            // remove existing event listener\n            const listener = target[XHR_LISTENER];\n            if (!oriAddListener) {\n                oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n                oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n            }\n            if (listener) {\n                oriRemoveListener.call(target, READY_STATE_CHANGE, listener);\n            }\n            const newListener = target[XHR_LISTENER] = () => {\n                if (target.readyState === target.DONE) {\n                    // sometimes on some browsers XMLHttpRequest will fire onreadystatechange with\n                    // readyState=4 multiple times, so we need to check task state here\n                    if (!data.aborted && target[XHR_SCHEDULED] && task.state === SCHEDULED) {\n                        // check whether the xhr has registered onload listener\n                        // if that is the case, the task should invoke after all\n                        // onload listeners finish.\n                        // Also if the request failed without response (status = 0), the load event handler\n                        // will not be triggered, in that case, we should also invoke the placeholder callback\n                        // to close the XMLHttpRequest::send macroTask.\n                        // https://github.com/angular/angular/issues/38795\n                        const loadTasks = target[Zone.__symbol__('loadfalse')];\n                        if (target.status !== 0 && loadTasks && loadTasks.length > 0) {\n                            const oriInvoke = task.invoke;\n                            task.invoke = function () {\n                                // need to load the tasks again, because in other\n                                // load listener, they may remove themselves\n                                const loadTasks = target[Zone.__symbol__('loadfalse')];\n                                for (let i = 0; i < loadTasks.length; i++) {\n                                    if (loadTasks[i] === task) {\n                                        loadTasks.splice(i, 1);\n                                    }\n                                }\n                                if (!data.aborted && task.state === SCHEDULED) {\n                                    oriInvoke.call(task);\n                                }\n                            };\n                            loadTasks.push(task);\n                        }\n                        else {\n                            task.invoke();\n                        }\n                    }\n                    else if (!data.aborted && target[XHR_SCHEDULED] === false) {\n                        // error occurs when xhr.send()\n                        target[XHR_ERROR_BEFORE_SCHEDULED] = true;\n                    }\n                }\n            };\n            oriAddListener.call(target, READY_STATE_CHANGE, newListener);\n            const storedTask = target[XHR_TASK];\n            if (!storedTask) {\n                target[XHR_TASK] = task;\n            }\n            sendNative.apply(target, data.args);\n            target[XHR_SCHEDULED] = true;\n            return task;\n        }\n        function placeholderCallback() { }\n        function clearTask(task) {\n            const data = task.data;\n            // Note - ideally, we would call data.target.removeEventListener here, but it's too late\n            // to prevent it from firing. So instead, we store info for the event listener.\n            data.aborted = true;\n            return abortNative.apply(data.target, data.args);\n        }\n        const openNative = patchMethod(XMLHttpRequestPrototype, 'open', () => function (self, args) {\n            self[XHR_SYNC] = args[2] == false;\n            self[XHR_URL] = args[1];\n            return openNative.apply(self, args);\n        });\n        const XMLHTTPREQUEST_SOURCE = 'XMLHttpRequest.send';\n        const fetchTaskAborting = zoneSymbol('fetchTaskAborting');\n        const fetchTaskScheduling = zoneSymbol('fetchTaskScheduling');\n        const sendNative = patchMethod(XMLHttpRequestPrototype, 'send', () => function (self, args) {\n            if (Zone.current[fetchTaskScheduling] === true) {\n                // a fetch is scheduling, so we are using xhr to polyfill fetch\n                // and because we already schedule macroTask for fetch, we should\n                // not schedule a macroTask for xhr again\n                return sendNative.apply(self, args);\n            }\n            if (self[XHR_SYNC]) {\n                // if the XHR is sync there is no task to schedule, just execute the code.\n                return sendNative.apply(self, args);\n            }\n            else {\n                const options = { target: self, url: self[XHR_URL], isPeriodic: false, args: args, aborted: false };\n                const task = scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);\n                if (self && self[XHR_ERROR_BEFORE_SCHEDULED] === true && !options.aborted &&\n                    task.state === SCHEDULED) {\n                    // xhr request throw error when send\n                    // we should invoke task instead of leaving a scheduled\n                    // pending macroTask\n                    task.invoke();\n                }\n            }\n        });\n        const abortNative = patchMethod(XMLHttpRequestPrototype, 'abort', () => function (self, args) {\n            const task = findPendingTask(self);\n            if (task && typeof task.type == 'string') {\n                // If the XHR has already completed, do nothing.\n                // If the XHR has already been aborted, do nothing.\n                // Fix #569, call abort multiple times before done will cause\n                // macroTask task count be negative number\n                if (task.cancelFn == null || (task.data && task.data.aborted)) {\n                    return;\n                }\n                task.zone.cancelTask(task);\n            }\n            else if (Zone.current[fetchTaskAborting] === true) {\n                // the abort is called from fetch polyfill, we need to call native abort of XHR.\n                return abortNative.apply(self, args);\n            }\n            // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no\n            // task\n            // to cancel. Do nothing.\n        });\n    }\n});\nZone.__load_patch('geolocation', (global) => {\n    /// GEO_LOCATION\n    if (global['navigator'] && global['navigator'].geolocation) {\n        patchPrototype(global['navigator'].geolocation, ['getCurrentPosition', 'watchPosition']);\n    }\n});\nZone.__load_patch('PromiseRejectionEvent', (global, Zone) => {\n    // handle unhandled promise rejection\n    function findPromiseRejectionHandler(evtName) {\n        return function (e) {\n            const eventTasks = findEventTasks(global, evtName);\n            eventTasks.forEach(eventTask => {\n                // windows has added unhandledrejection event listener\n                // trigger the event listener\n                const PromiseRejectionEvent = global['PromiseRejectionEvent'];\n                if (PromiseRejectionEvent) {\n                    const evt = new PromiseRejectionEvent(evtName, { promise: e.promise, reason: e.rejection });\n                    eventTask.invoke(evt);\n                }\n            });\n        };\n    }\n    if (global['PromiseRejectionEvent']) {\n        Zone[zoneSymbol('unhandledPromiseRejectionHandler')] =\n            findPromiseRejectionHandler('unhandledrejection');\n        Zone[zoneSymbol('rejectionHandledHandler')] =\n            findPromiseRejectionHandler('rejectionhandled');\n    }\n});\n","/**\n * @license Angular v12.2.13\n * (c) 2010-2021 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst __globalThis = typeof globalThis !== 'undefined' && globalThis;\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\n// Always use __globalThis if available; this is the spec-defined global variable across all\n// environments.\n// Then fallback to __global first; in Node tests both __global and __window may be defined.\nconst _global = __globalThis || __global || __window || __self;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Tag a template literal string for localization.\n *\n * For example:\n *\n * ```ts\n * $localize `some string to localize`\n * ```\n *\n * **Providing meaning, description and id**\n *\n * You can optionally specify one or more of `meaning`, `description` and `id` for a localized\n * string by pre-pending it with a colon delimited block of the form:\n *\n * ```ts\n * $localize`:meaning|description@@id:source message text`;\n *\n * $localize`:meaning|:source message text`;\n * $localize`:description:source message text`;\n * $localize`:@@id:source message text`;\n * ```\n *\n * This format is the same as that used for `i18n` markers in Angular templates. See the\n * [Angular i18n guide](guide/i18n-common-prepare#mark-text-in-component-template).\n *\n * **Naming placeholders**\n *\n * If the template literal string contains expressions, then the expressions will be automatically\n * associated with placeholder names for you.\n *\n * For example:\n *\n * ```ts\n * $localize `Hi ${name}! There are ${items.length} items.`;\n * ```\n *\n * will generate a message-source of `Hi {$PH}! There are {$PH_1} items`.\n *\n * The recommended practice is to name the placeholder associated with each expression though.\n *\n * Do this by providing the placeholder name wrapped in `:` characters directly after the\n * expression. These placeholder names are stripped out of the rendered localized string.\n *\n * For example, to name the `items.length` expression placeholder `itemCount` you write:\n *\n * ```ts\n * $localize `There are ${items.length}:itemCount: items`;\n * ```\n *\n * **Escaping colon markers**\n *\n * If you need to use a `:` character directly at the start of a tagged string that has no\n * metadata block, or directly after a substitution expression that has no name you must escape\n * the `:` by preceding it with a backslash:\n *\n * For example:\n *\n * ```ts\n * // message has a metadata block so no need to escape colon\n * $localize `:some description::this message starts with a colon (:)`;\n * // no metadata block so the colon must be escaped\n * $localize `\\:this message starts with a colon (:)`;\n * ```\n *\n * ```ts\n * // named substitution so no need to escape colon\n * $localize `${label}:label:: ${}`\n * // anonymous substitution so colon must be escaped\n * $localize `${label}\\: ${}`\n * ```\n *\n * **Processing localized strings:**\n *\n * There are three scenarios:\n *\n * * **compile-time inlining**: the `$localize` tag is transformed at compile time by a\n * transpiler, removing the tag and replacing the template literal string with a translated\n * literal string from a collection of translations provided to the transpilation tool.\n *\n * * **run-time evaluation**: the `$localize` tag is a run-time function that replaces and\n * reorders the parts (static strings and expressions) of the template literal string with strings\n * from a collection of translations loaded at run-time.\n *\n * * **pass-through evaluation**: the `$localize` tag is a run-time function that simply evaluates\n * the original template literal string without applying any translations to the parts. This\n * version is used during development or where there is no need to translate the localized\n * template literals.\n *\n * @param messageParts a collection of the static parts of the template string.\n * @param expressions a collection of the values of each placeholder in the template string.\n * @returns the translated string, with the `messageParts` and `expressions` interleaved together.\n *\n * @globalApi\n * @publicApi\n */\nconst $localize = function (messageParts, ...expressions) {\n    if ($localize.translate) {\n        // Don't use array expansion here to avoid the compiler adding `__read()` helper unnecessarily.\n        const translation = $localize.translate(messageParts, expressions);\n        messageParts = translation[0];\n        expressions = translation[1];\n    }\n    let message = stripBlock(messageParts[0], messageParts.raw[0]);\n    for (let i = 1; i < messageParts.length; i++) {\n        message += expressions[i - 1] + stripBlock(messageParts[i], messageParts.raw[i]);\n    }\n    return message;\n};\nconst BLOCK_MARKER = ':';\n/**\n * Strip a delimited \"block\" from the start of the `messagePart`, if it is found.\n *\n * If a marker character (:) actually appears in the content at the start of a tagged string or\n * after a substitution expression, where a block has not been provided the character must be\n * escaped with a backslash, `\\:`. This function checks for this by looking at the `raw`\n * messagePart, which should still contain the backslash.\n *\n * @param messagePart The cooked message part to process.\n * @param rawMessagePart The raw message part to check.\n * @returns the message part with the placeholder name stripped, if found.\n * @throws an error if the block is unterminated\n */\nfunction stripBlock(messagePart, rawMessagePart) {\n    return rawMessagePart.charAt(0) === BLOCK_MARKER ?\n        messagePart.substring(findEndOfBlock(messagePart, rawMessagePart) + 1) :\n        messagePart;\n}\n/**\n * Find the end of a \"marked block\" indicated by the first non-escaped colon.\n *\n * @param cooked The cooked string (where escaped chars have been processed)\n * @param raw The raw string (where escape sequences are still in place)\n *\n * @returns the index of the end of block marker\n * @throws an error if the block is unterminated\n */\nfunction findEndOfBlock(cooked, raw) {\n    /***********************************************************************************************\n     * This function is repeated in `src/utils/messages.ts` and the two should be kept in sync.\n     * The reason is that this file is marked as having side-effects, and if we import `messages.ts`\n     * into it, the whole of `src/utils` will be included in this bundle and none of the functions\n     * will be tree shaken.\n     ***********************************************************************************************/\n    for (let cookedIndex = 1, rawIndex = 1; cookedIndex < cooked.length; cookedIndex++, rawIndex++) {\n        if (raw[rawIndex] === '\\\\') {\n            rawIndex++;\n        }\n        else if (cooked[cookedIndex] === BLOCK_MARKER) {\n            return cookedIndex;\n        }\n    }\n    throw new Error(`Unterminated $localize metadata block in \"${raw}\".`);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Attach $localize to the global context, as a side-effect of this module.\n_global.$localize = $localize;\n\nexport { $localize };\n","/***************************************************************************************************\r\n * Load `$localize` onto the global scope - used if i18n tags appear in Angular templates.\r\n */\r\nimport '@angular/localize/init';\r\n/**\r\n * This file includes polyfills needed by Angular and is loaded before the app.\r\n * You can add your own extra polyfills to this file.\r\n *\r\n * This file is divided into 2 sections:\r\n *   1. Browser polyfills. These are applied before loading ZoneJS and are sorted by browsers.\r\n *   2. Application imports. Files imported after ZoneJS that should be loaded before your main\r\n *      file.\r\n *\r\n * The current setup is for so-called \"evergreen\" browsers; the last versions of browsers that\r\n * automatically update themselves. This includes Safari >= 10, Chrome >= 55 (including Opera),\r\n * Edge >= 13 on the desktop, and iOS 10 and Chrome on mobile.\r\n *\r\n * Learn more in https://angular.io/guide/browser-support\r\n */\r\n\r\n/***************************************************************************************************\r\n * BROWSER POLYFILLS\r\n */\r\n\r\n/**\r\n * IE11 requires the following for NgClass support on SVG elements\r\n */\r\n// import 'classlist.js';  // Run `npm install --save classlist.js`.\r\n\r\n/**\r\n * Web Animations `@angular/platform-browser/animations`\r\n * Only required if AnimationBuilder is used within the application and using IE/Edge or Safari.\r\n * Standard animation support in Angular DOES NOT require any polyfills (as of Angular 6.0).\r\n */\r\n// import 'web-animations-js';  // Run `npm install --save web-animations-js`.\r\n\r\n/**\r\n * By default, zone.js will patch all possible macroTask and DomEvents\r\n * user can disable parts of macroTask/DomEvents patch by setting following flags\r\n * because those flags need to be set before `zone.js` being loaded, and webpack\r\n * will put import in the top of bundle, so user need to create a separate file\r\n * in this directory (for example: zone-flags.ts), and put the following flags\r\n * into that file, and then add the following code before importing zone.js.\r\n * import './zone-flags';\r\n *\r\n * The flags allowed in zone-flags.ts are listed here.\r\n *\r\n * The following flags will work for all browsers.\r\n *\r\n * (window as any).__Zone_disable_requestAnimationFrame = true; // disable patch requestAnimationFrame\r\n * (window as any).__Zone_disable_on_property = true; // disable patch onProperty such as onclick\r\n * (window as any).__zone_symbol__UNPATCHED_EVENTS = ['scroll', 'mousemove']; // disable patch specified eventNames\r\n *\r\n *  in IE/Edge developer tools, the addEventListener will also be wrapped by zone.js\r\n *  with the following flag, it will bypass `zone.js` patch for IE/Edge\r\n *\r\n *  (window as any).__Zone_enable_cross_context_check = true;\r\n *\r\n */\r\n\r\n/***************************************************************************************************\r\n * Zone JS is required by default for Angular itself.\r\n */\r\nimport 'zone.js'; // Included with Angular CLI.\r\n\r\nimport * as process from 'process';\r\nimport { Buffer } from 'buffer';\r\n\r\nwindow.process = process;\r\n(window as any).global = window;\r\nglobal.Buffer = global.Buffer || Buffer;\r\n\r\n/***************************************************************************************************\r\n * APPLICATION IMPORTS\r\n */\r\n"],"sourceRoot":"webpack:///","file":"polyfills.js"}